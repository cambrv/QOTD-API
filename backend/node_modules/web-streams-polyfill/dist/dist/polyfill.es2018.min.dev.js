"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

function _asyncGeneratorDelegate(inner, awaitWrap) { var iter = {}, waiting = false; function pump(key, value) { waiting = true; value = new Promise(function (resolve) { resolve(inner[key](value)); }); return { done: false, value: awaitWrap(value) }; } ; if (typeof Symbol === "function" && Symbol.iterator) { iter[Symbol.iterator] = function () { return this; }; } iter.next = function (value) { if (waiting) { waiting = false; return value; } return pump("next", value); }; if (typeof inner["throw"] === "function") { iter["throw"] = function (value) { if (waiting) { waiting = false; throw value; } return pump("throw", value); }; } if (typeof inner["return"] === "function") { iter["return"] = function (value) { if (waiting) { waiting = false; return value; } return pump("return", value); }; } return iter; }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen["return"] !== "function") { this["return"] = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

/**
 * @license
 * web-streams-polyfill v3.3.3
 * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).WebStreamsPolyfill = {});
}(void 0, function (e) {
  "use strict";

  function t() {}

  function r(e) {
    return "object" == _typeof(e) && null !== e || "function" == typeof e;
  }

  var o = t;

  function n(e, t) {
    try {
      Object.defineProperty(e, "name", {
        value: t,
        configurable: !0
      });
    } catch (e) {}
  }

  var a = Promise,
      i = Promise.prototype.then,
      l = Promise.reject.bind(a);

  function s(e) {
    return new a(e);
  }

  function u(e) {
    return s(function (t) {
      return t(e);
    });
  }

  function c(e) {
    return l(e);
  }

  function d(e, t, r) {
    return i.call(e, t, r);
  }

  function f(e, t, r) {
    d(d(e, t, r), void 0, o);
  }

  function b(e, t) {
    f(e, t);
  }

  function m(e, t) {
    f(e, void 0, t);
  }

  function h(e, t, r) {
    return d(e, t, r);
  }

  function _(e) {
    d(e, void 0, o);
  }

  var _p = function p(e) {
    if ("function" == typeof queueMicrotask) _p = queueMicrotask;else {
      var _e2 = u(void 0);

      _p = function p(t) {
        return d(_e2, t);
      };
    }
    return _p(e);
  };

  function y(e, t, r) {
    if ("function" != typeof e) throw new TypeError("Argument is not a function");
    return Function.prototype.apply.call(e, t, r);
  }

  function S(e, t, r) {
    try {
      return u(y(e, t, r));
    } catch (e) {
      return c(e);
    }
  }

  var g =
  /*#__PURE__*/
  function () {
    function g() {
      _classCallCheck(this, g);

      this._cursor = 0, this._size = 0, this._front = {
        _elements: [],
        _next: void 0
      }, this._back = this._front, this._cursor = 0, this._size = 0;
    }

    _createClass(g, [{
      key: "push",
      value: function push(e) {
        var t = this._back;
        var r = t;
        16383 === t._elements.length && (r = {
          _elements: [],
          _next: void 0
        }), t._elements.push(e), r !== t && (this._back = r, t._next = r), ++this._size;
      }
    }, {
      key: "shift",
      value: function shift() {
        var e = this._front;
        var t = e;
        var r = this._cursor;
        var o = r + 1;
        var n = e._elements,
            a = n[r];
        return 16384 === o && (t = e._next, o = 0), --this._size, this._cursor = o, e !== t && (this._front = t), n[r] = void 0, a;
      }
    }, {
      key: "forEach",
      value: function forEach(e) {
        var t = this._cursor,
            r = this._front,
            o = r._elements;

        for (; !(t === o.length && void 0 === r._next || t === o.length && (r = r._next, o = r._elements, t = 0, 0 === o.length));) {
          e(o[t]), ++t;
        }
      }
    }, {
      key: "peek",
      value: function peek() {
        var e = this._front,
            t = this._cursor;
        return e._elements[t];
      }
    }, {
      key: "length",
      get: function get() {
        return this._size;
      }
    }]);

    return g;
  }();

  var v = Symbol("[[AbortSteps]]"),
      w = Symbol("[[ErrorSteps]]"),
      R = Symbol("[[CancelSteps]]"),
      T = Symbol("[[PullSteps]]"),
      C = Symbol("[[ReleaseSteps]]");

  function P(e, t) {
    e._ownerReadableStream = t, t._reader = e, "readable" === t._state ? B(e) : "closed" === t._state ? function (e) {
      B(e), k(e);
    }(e) : O(e, t._storedError);
  }

  function q(e, t) {
    return Er(e._ownerReadableStream, t);
  }

  function E(e) {
    var t = e._ownerReadableStream;
    "readable" === t._state ? j(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function (e, t) {
      O(e, t);
    }(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), t._readableStreamController[C](), t._reader = void 0, e._ownerReadableStream = void 0;
  }

  function W(e) {
    return new TypeError("Cannot " + e + " a stream using a released reader");
  }

  function B(e) {
    e._closedPromise = s(function (t, r) {
      e._closedPromise_resolve = t, e._closedPromise_reject = r;
    });
  }

  function O(e, t) {
    B(e), j(e, t);
  }

  function j(e, t) {
    void 0 !== e._closedPromise_reject && (_(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);
  }

  function k(e) {
    void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);
  }

  var A = Number.isFinite || function (e) {
    return "number" == typeof e && isFinite(e);
  },
      D = Math.trunc || function (e) {
    return e < 0 ? Math.ceil(e) : Math.floor(e);
  };

  function z(e, t) {
    if (void 0 !== e && "object" != _typeof(r = e) && "function" != typeof r) throw new TypeError("".concat(t, " is not an object."));
    var r;
  }

  function L(e, t) {
    if ("function" != typeof e) throw new TypeError("".concat(t, " is not a function."));
  }

  function F(e, t) {
    if (!function (e) {
      return "object" == _typeof(e) && null !== e || "function" == typeof e;
    }(e)) throw new TypeError("".concat(t, " is not an object."));
  }

  function I(e, t, r) {
    if (void 0 === e) throw new TypeError("Parameter ".concat(t, " is required in '").concat(r, "'."));
  }

  function $(e, t, r) {
    if (void 0 === e) throw new TypeError("".concat(t, " is required in '").concat(r, "'."));
  }

  function M(e) {
    return Number(e);
  }

  function Y(e) {
    return 0 === e ? 0 : e;
  }

  function Q(e, t) {
    var r = Number.MAX_SAFE_INTEGER;
    var o = Number(e);
    if (o = Y(o), !A(o)) throw new TypeError("".concat(t, " is not a finite number"));
    if (o = function (e) {
      return Y(D(e));
    }(o), o < 0 || o > r) throw new TypeError("".concat(t, " is outside the accepted range of 0 to ").concat(r, ", inclusive"));
    return A(o) && 0 !== o ? o : 0;
  }

  function x(e, t) {
    if (!Pr(e)) throw new TypeError("".concat(t, " is not a ReadableStream."));
  }

  function N(e) {
    return new ReadableStreamDefaultReader(e);
  }

  function H(e, t) {
    e._reader._readRequests.push(t);
  }

  function V(e, t, r) {
    var o = e._reader._readRequests.shift();

    r ? o._closeSteps() : o._chunkSteps(t);
  }

  function U(e) {
    return e._reader._readRequests.length;
  }

  function G(e) {
    var t = e._reader;
    return void 0 !== t && !!X(t);
  }

  var ReadableStreamDefaultReader =
  /*#__PURE__*/
  function () {
    function ReadableStreamDefaultReader(e) {
      _classCallCheck(this, ReadableStreamDefaultReader);

      if (I(e, 1, "ReadableStreamDefaultReader"), x(e, "First parameter"), qr(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      P(this, e), this._readRequests = new g();
    }

    _createClass(ReadableStreamDefaultReader, [{
      key: "cancel",
      value: function cancel() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return X(this) ? void 0 === this._ownerReadableStream ? c(W("cancel")) : q(this, e) : c(Z("cancel"));
      }
    }, {
      key: "read",
      value: function read() {
        if (!X(this)) return c(Z("read"));
        if (void 0 === this._ownerReadableStream) return c(W("read from"));
        var e, t;
        var r = s(function (r, o) {
          e = r, t = o;
        });
        return J(this, {
          _chunkSteps: function _chunkSteps(t) {
            return e({
              value: t,
              done: !1
            });
          },
          _closeSteps: function _closeSteps() {
            return e({
              value: void 0,
              done: !0
            });
          },
          _errorSteps: function _errorSteps(e) {
            return t(e);
          }
        }), r;
      }
    }, {
      key: "releaseLock",
      value: function releaseLock() {
        if (!X(this)) throw Z("releaseLock");
        void 0 !== this._ownerReadableStream && function (e) {
          E(e);
          var t = new TypeError("Reader was released");
          K(e, t);
        }(this);
      }
    }, {
      key: "closed",
      get: function get() {
        return X(this) ? this._closedPromise : c(Z("closed"));
      }
    }]);

    return ReadableStreamDefaultReader;
  }();

  function X(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_readRequests") && e instanceof ReadableStreamDefaultReader;
  }

  function J(e, t) {
    var r = e._ownerReadableStream;
    r._disturbed = !0, "closed" === r._state ? t._closeSteps() : "errored" === r._state ? t._errorSteps(r._storedError) : r._readableStreamController[T](t);
  }

  function K(e, t) {
    var r = e._readRequests;
    e._readRequests = new g(), r.forEach(function (e) {
      e._errorSteps(t);
    });
  }

  function Z(e) {
    return new TypeError("ReadableStreamDefaultReader.prototype.".concat(e, " can only be used on a ReadableStreamDefaultReader"));
  }

  Object.defineProperties(ReadableStreamDefaultReader.prototype, {
    cancel: {
      enumerable: !0
    },
    read: {
      enumerable: !0
    },
    releaseLock: {
      enumerable: !0
    },
    closed: {
      enumerable: !0
    }
  }), n(ReadableStreamDefaultReader.prototype.cancel, "cancel"), n(ReadableStreamDefaultReader.prototype.read, "read"), n(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
    value: "ReadableStreamDefaultReader",
    configurable: !0
  });
  var ee = Object.getPrototypeOf(Object.getPrototypeOf(
  /*#__PURE__*/
  _wrapAsyncGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }))).prototype);

  var te =
  /*#__PURE__*/
  function () {
    function te(e, t) {
      _classCallCheck(this, te);

      this._ongoingPromise = void 0, this._isFinished = !1, this._reader = e, this._preventCancel = t;
    }

    _createClass(te, [{
      key: "next",
      value: function next() {
        var _this = this;

        var e = function e() {
          return _this._nextSteps();
        };

        return this._ongoingPromise = this._ongoingPromise ? h(this._ongoingPromise, e, e) : e(), this._ongoingPromise;
      }
    }, {
      key: "return",
      value: function _return(e) {
        var _this2 = this;

        var t = function t() {
          return _this2._returnSteps(e);
        };

        return this._ongoingPromise ? h(this._ongoingPromise, t, t) : t();
      }
    }, {
      key: "_nextSteps",
      value: function _nextSteps() {
        var _this3 = this;

        if (this._isFinished) return Promise.resolve({
          value: void 0,
          done: !0
        });
        var e = this._reader;
        var t, r;
        var o = s(function (e, o) {
          t = e, r = o;
        });
        return J(e, {
          _chunkSteps: function _chunkSteps(e) {
            _this3._ongoingPromise = void 0, _p(function () {
              return t({
                value: e,
                done: !1
              });
            });
          },
          _closeSteps: function _closeSteps() {
            _this3._ongoingPromise = void 0, _this3._isFinished = !0, E(e), t({
              value: void 0,
              done: !0
            });
          },
          _errorSteps: function _errorSteps(t) {
            _this3._ongoingPromise = void 0, _this3._isFinished = !0, E(e), r(t);
          }
        }), o;
      }
    }, {
      key: "_returnSteps",
      value: function _returnSteps(e) {
        if (this._isFinished) return Promise.resolve({
          value: e,
          done: !0
        });
        this._isFinished = !0;
        var t = this._reader;

        if (!this._preventCancel) {
          var _r2 = q(t, e);

          return E(t), h(_r2, function () {
            return {
              value: e,
              done: !0
            };
          });
        }

        return E(t), u({
          value: e,
          done: !0
        });
      }
    }]);

    return te;
  }();

  var re = {
    next: function next() {
      return oe(this) ? this._asyncIteratorImpl.next() : c(ne("next"));
    },
    "return": function _return(e) {
      return oe(this) ? this._asyncIteratorImpl["return"](e) : c(ne("return"));
    }
  };

  function oe(e) {
    if (!r(e)) return !1;
    if (!Object.prototype.hasOwnProperty.call(e, "_asyncIteratorImpl")) return !1;

    try {
      return e._asyncIteratorImpl instanceof te;
    } catch (e) {
      return !1;
    }
  }

  function ne(e) {
    return new TypeError("ReadableStreamAsyncIterator.".concat(e, " can only be used on a ReadableSteamAsyncIterator"));
  }

  Object.setPrototypeOf(re, ee);

  var ae = Number.isNaN || function (e) {
    return e != e;
  };

  var ie, le, se;

  function ue(e) {
    return e.slice();
  }

  function ce(e, t, r, o, n) {
    new Uint8Array(e).set(new Uint8Array(r, o, n), t);
  }

  var _de = function de(e) {
    return _de = "function" == typeof e.transfer ? function (e) {
      return e.transfer();
    } : "function" == typeof structuredClone ? function (e) {
      return structuredClone(e, {
        transfer: [e]
      });
    } : function (e) {
      return e;
    }, _de(e);
  },
      _fe = function fe(e) {
    return _fe = "boolean" == typeof e.detached ? function (e) {
      return e.detached;
    } : function (e) {
      return 0 === e.byteLength;
    }, _fe(e);
  };

  function be(e, t, r) {
    if (e.slice) return e.slice(t, r);
    var o = r - t,
        n = new ArrayBuffer(o);
    return ce(n, 0, e, t, o), n;
  }

  function me(e, t) {
    var r = e[t];

    if (null != r) {
      if ("function" != typeof r) throw new TypeError("".concat(String(t), " is not a function"));
      return r;
    }
  }

  var he = null !== (se = null !== (ie = Symbol.asyncIterator) && void 0 !== ie ? ie : null === (le = Symbol["for"]) || void 0 === le ? void 0 : le.call(Symbol, "Symbol.asyncIterator")) && void 0 !== se ? se : "@@asyncIterator";

  function _e(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "sync";
    var o = arguments.length > 2 ? arguments[2] : undefined;
    if (void 0 === o) if ("async" === t) {
      if (void 0 === (o = me(e, he))) {
        return function (e) {
          var t = _defineProperty({}, Symbol.iterator, function () {
            return e.iterator;
          }),
              r = _wrapAsyncGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee2() {
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(t), _awaitAsyncGenerator), "t0", 1);

                  case 1:
                    return _context2.abrupt("return", _context2.t0);

                  case 2:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }))();

          return {
            iterator: r,
            nextMethod: r.next,
            done: !1
          };
        }(_e(e, "sync", me(e, Symbol.iterator)));
      }
    } else o = me(e, Symbol.iterator);
    if (void 0 === o) throw new TypeError("The object is not iterable");
    var n = y(o, e, []);
    if (!r(n)) throw new TypeError("The iterator method must return an object");
    return {
      iterator: n,
      nextMethod: n.next,
      done: !1
    };
  }

  function pe(e) {
    var t = be(e.buffer, e.byteOffset, e.byteOffset + e.byteLength);
    return new Uint8Array(t);
  }

  function ye(e) {
    var t = e._queue.shift();

    return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value;
  }

  function Se(e, t, r) {
    if ("number" != typeof (o = r) || ae(o) || o < 0 || r === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
    var o;
    e._queue.push({
      value: t,
      size: r
    }), e._queueTotalSize += r;
  }

  function ge(e) {
    e._queue = new g(), e._queueTotalSize = 0;
  }

  function ve(e) {
    return e === DataView;
  }

  var ReadableStreamBYOBRequest =
  /*#__PURE__*/
  function () {
    function ReadableStreamBYOBRequest() {
      _classCallCheck(this, ReadableStreamBYOBRequest);

      throw new TypeError("Illegal constructor");
    }

    _createClass(ReadableStreamBYOBRequest, [{
      key: "respond",
      value: function respond(e) {
        if (!Re(this)) throw Ge("respond");
        if (I(e, 1, "respond"), e = Q(e, "First parameter"), void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        if (_fe(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
        He(this._associatedReadableByteStreamController, e);
      }
    }, {
      key: "respondWithNewView",
      value: function respondWithNewView(e) {
        if (!Re(this)) throw Ge("respondWithNewView");
        if (I(e, 1, "respondWithNewView"), !ArrayBuffer.isView(e)) throw new TypeError("You can only respond with array buffer views");
        if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
        if (_fe(e.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
        Ve(this._associatedReadableByteStreamController, e);
      }
    }, {
      key: "view",
      get: function get() {
        if (!Re(this)) throw Ge("view");
        return this._view;
      }
    }]);

    return ReadableStreamBYOBRequest;
  }();

  Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
    respond: {
      enumerable: !0
    },
    respondWithNewView: {
      enumerable: !0
    },
    view: {
      enumerable: !0
    }
  }), n(ReadableStreamBYOBRequest.prototype.respond, "respond"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
    value: "ReadableStreamBYOBRequest",
    configurable: !0
  });

  var ReadableByteStreamController =
  /*#__PURE__*/
  function () {
    function ReadableByteStreamController() {
      _classCallCheck(this, ReadableByteStreamController);

      throw new TypeError("Illegal constructor");
    }

    _createClass(ReadableByteStreamController, [{
      key: "close",
      value: function close() {
        if (!we(this)) throw Xe("close");
        if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
        var e = this._controlledReadableByteStream._state;
        if ("readable" !== e) throw new TypeError("The stream (in ".concat(e, " state) is not in the readable state and cannot be closed"));
        $e(this);
      }
    }, {
      key: "enqueue",
      value: function enqueue(e) {
        if (!we(this)) throw Xe("enqueue");
        if (I(e, 1, "enqueue"), !ArrayBuffer.isView(e)) throw new TypeError("chunk must be an array buffer view");
        if (0 === e.byteLength) throw new TypeError("chunk must have non-zero byteLength");
        if (0 === e.buffer.byteLength) throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested) throw new TypeError("stream is closed or draining");
        var t = this._controlledReadableByteStream._state;
        if ("readable" !== t) throw new TypeError("The stream (in ".concat(t, " state) is not in the readable state and cannot be enqueued to"));
        Me(this, e);
      }
    }, {
      key: "error",
      value: function error() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!we(this)) throw Xe("error");
        Ye(this, e);
      }
    }, {
      key: R,
      value: function value(e) {
        Ce(this), ge(this);

        var t = this._cancelAlgorithm(e);

        return Ie(this), t;
      }
    }, {
      key: T,
      value: function value(e) {
        var t = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) return void Qe(this, e);
        var r = this._autoAllocateChunkSize;

        if (void 0 !== r) {
          var _t3;

          try {
            _t3 = new ArrayBuffer(r);
          } catch (t) {
            return void e._errorSteps(t);
          }

          var _o = {
            buffer: _t3,
            bufferByteLength: r,
            byteOffset: 0,
            byteLength: r,
            bytesFilled: 0,
            minimumFill: 1,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };

          this._pendingPullIntos.push(_o);
        }

        H(t, e), Te(this);
      }
    }, {
      key: C,
      value: function value() {
        if (this._pendingPullIntos.length > 0) {
          var _e3 = this._pendingPullIntos.peek();

          _e3.readerType = "none", this._pendingPullIntos = new g(), this._pendingPullIntos.push(_e3);
        }
      }
    }, {
      key: "byobRequest",
      get: function get() {
        if (!we(this)) throw Xe("byobRequest");
        return xe(this);
      }
    }, {
      key: "desiredSize",
      get: function get() {
        if (!we(this)) throw Xe("desiredSize");
        return Ne(this);
      }
    }]);

    return ReadableByteStreamController;
  }();

  function we(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream") && e instanceof ReadableByteStreamController;
  }

  function Re(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_associatedReadableByteStreamController") && e instanceof ReadableStreamBYOBRequest;
  }

  function Te(e) {
    var t = function (e) {
      var t = e._controlledReadableByteStream;
      if ("readable" !== t._state) return !1;
      if (e._closeRequested) return !1;
      if (!e._started) return !1;
      if (G(t) && U(t) > 0) return !0;
      if (tt(t) && et(t) > 0) return !0;
      var r = Ne(e);
      if (r > 0) return !0;
      return !1;
    }(e);

    if (!t) return;
    if (e._pulling) return void (e._pullAgain = !0);
    e._pulling = !0;
    f(e._pullAlgorithm(), function () {
      return e._pulling = !1, e._pullAgain && (e._pullAgain = !1, Te(e)), null;
    }, function (t) {
      return Ye(e, t), null;
    });
  }

  function Ce(e) {
    Ae(e), e._pendingPullIntos = new g();
  }

  function Pe(e, t) {
    var r = !1;
    "closed" === e._state && (r = !0);
    var o = qe(t);
    "default" === t.readerType ? V(e, o, r) : function (e, t, r) {
      var o = e._reader,
          n = o._readIntoRequests.shift();

      r ? n._closeSteps(t) : n._chunkSteps(t);
    }(e, o, r);
  }

  function qe(e) {
    var t = e.bytesFilled,
        r = e.elementSize;
    return new e.viewConstructor(e.buffer, e.byteOffset, t / r);
  }

  function Ee(e, t, r, o) {
    e._queue.push({
      buffer: t,
      byteOffset: r,
      byteLength: o
    }), e._queueTotalSize += o;
  }

  function We(e, t, r, o) {
    var n;

    try {
      n = be(t, r, r + o);
    } catch (t) {
      throw Ye(e, t), t;
    }

    Ee(e, n, 0, o);
  }

  function Be(e, t) {
    t.bytesFilled > 0 && We(e, t.buffer, t.byteOffset, t.bytesFilled), Fe(e);
  }

  function Oe(e, t) {
    var r = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled),
        o = t.bytesFilled + r;
    var n = r,
        a = !1;
    var i = o - o % t.elementSize;
    i >= t.minimumFill && (n = i - t.bytesFilled, a = !0);
    var l = e._queue;

    for (; n > 0;) {
      var _r3 = l.peek(),
          _o2 = Math.min(n, _r3.byteLength),
          _a = t.byteOffset + t.bytesFilled;

      ce(t.buffer, _a, _r3.buffer, _r3.byteOffset, _o2), _r3.byteLength === _o2 ? l.shift() : (_r3.byteOffset += _o2, _r3.byteLength -= _o2), e._queueTotalSize -= _o2, je(e, _o2, t), n -= _o2;
    }

    return a;
  }

  function je(e, t, r) {
    r.bytesFilled += t;
  }

  function ke(e) {
    0 === e._queueTotalSize && e._closeRequested ? (Ie(e), Wr(e._controlledReadableByteStream)) : Te(e);
  }

  function Ae(e) {
    null !== e._byobRequest && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = null, e._byobRequest = null);
  }

  function De(e) {
    for (; e._pendingPullIntos.length > 0;) {
      if (0 === e._queueTotalSize) return;

      var _t4 = e._pendingPullIntos.peek();

      Oe(e, _t4) && (Fe(e), Pe(e._controlledReadableByteStream, _t4));
    }
  }

  function ze(e, t, r, o) {
    var n = e._controlledReadableByteStream,
        a = t.constructor,
        i = function (e) {
      return ve(e) ? 1 : e.BYTES_PER_ELEMENT;
    }(a),
        l = t.byteOffset,
        s = t.byteLength,
        u = r * i;

    var c;

    try {
      c = _de(t.buffer);
    } catch (e) {
      return void o._errorSteps(e);
    }

    var d = {
      buffer: c,
      bufferByteLength: c.byteLength,
      byteOffset: l,
      byteLength: s,
      bytesFilled: 0,
      minimumFill: u,
      elementSize: i,
      viewConstructor: a,
      readerType: "byob"
    };
    if (e._pendingPullIntos.length > 0) return e._pendingPullIntos.push(d), void Ze(n, o);

    if ("closed" !== n._state) {
      if (e._queueTotalSize > 0) {
        if (Oe(e, d)) {
          var _t5 = qe(d);

          return ke(e), void o._chunkSteps(_t5);
        }

        if (e._closeRequested) {
          var _t6 = new TypeError("Insufficient bytes to fill elements in the given buffer");

          return Ye(e, _t6), void o._errorSteps(_t6);
        }
      }

      e._pendingPullIntos.push(d), Ze(n, o), Te(e);
    } else {
      var _e4 = new a(d.buffer, d.byteOffset, 0);

      o._closeSteps(_e4);
    }
  }

  function Le(e, t) {
    var r = e._pendingPullIntos.peek();

    Ae(e);
    "closed" === e._controlledReadableByteStream._state ? function (e, t) {
      "none" === t.readerType && Fe(e);
      var r = e._controlledReadableByteStream;
      if (tt(r)) for (; et(r) > 0;) {
        Pe(r, Fe(e));
      }
    }(e, r) : function (e, t, r) {
      if (je(0, t, r), "none" === r.readerType) return Be(e, r), void De(e);
      if (r.bytesFilled < r.minimumFill) return;
      Fe(e);
      var o = r.bytesFilled % r.elementSize;

      if (o > 0) {
        var _t7 = r.byteOffset + r.bytesFilled;

        We(e, r.buffer, _t7 - o, o);
      }

      r.bytesFilled -= o, Pe(e._controlledReadableByteStream, r), De(e);
    }(e, t, r), Te(e);
  }

  function Fe(e) {
    return e._pendingPullIntos.shift();
  }

  function Ie(e) {
    e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0;
  }

  function $e(e) {
    var t = e._controlledReadableByteStream;
    if (!e._closeRequested && "readable" === t._state) if (e._queueTotalSize > 0) e._closeRequested = !0;else {
      if (e._pendingPullIntos.length > 0) {
        var _t8 = e._pendingPullIntos.peek();

        if (_t8.bytesFilled % _t8.elementSize != 0) {
          var _t9 = new TypeError("Insufficient bytes to fill elements in the given buffer");

          throw Ye(e, _t9), _t9;
        }
      }

      Ie(e), Wr(t);
    }
  }

  function Me(e, t) {
    var r = e._controlledReadableByteStream;
    if (e._closeRequested || "readable" !== r._state) return;
    var o = t.buffer,
        n = t.byteOffset,
        a = t.byteLength;
    if (_fe(o)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");

    var i = _de(o);

    if (e._pendingPullIntos.length > 0) {
      var _t10 = e._pendingPullIntos.peek();

      if (_fe(_t10.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
      Ae(e), _t10.buffer = _de(_t10.buffer), "none" === _t10.readerType && Be(e, _t10);
    }

    if (G(r)) {
      if (function (e) {
        var t = e._controlledReadableByteStream._reader;

        for (; t._readRequests.length > 0;) {
          if (0 === e._queueTotalSize) return;
          Qe(e, t._readRequests.shift());
        }
      }(e), 0 === U(r)) Ee(e, i, n, a);else {
        e._pendingPullIntos.length > 0 && Fe(e);
        V(r, new Uint8Array(i, n, a), !1);
      }
    } else tt(r) ? (Ee(e, i, n, a), De(e)) : Ee(e, i, n, a);
    Te(e);
  }

  function Ye(e, t) {
    var r = e._controlledReadableByteStream;
    "readable" === r._state && (Ce(e), ge(e), Ie(e), Br(r, t));
  }

  function Qe(e, t) {
    var r = e._queue.shift();

    e._queueTotalSize -= r.byteLength, ke(e);
    var o = new Uint8Array(r.buffer, r.byteOffset, r.byteLength);

    t._chunkSteps(o);
  }

  function xe(e) {
    if (null === e._byobRequest && e._pendingPullIntos.length > 0) {
      var _t11 = e._pendingPullIntos.peek(),
          _r4 = new Uint8Array(_t11.buffer, _t11.byteOffset + _t11.bytesFilled, _t11.byteLength - _t11.bytesFilled),
          _o3 = Object.create(ReadableStreamBYOBRequest.prototype);

      !function (e, t, r) {
        e._associatedReadableByteStreamController = t, e._view = r;
      }(_o3, e, _r4), e._byobRequest = _o3;
    }

    return e._byobRequest;
  }

  function Ne(e) {
    var t = e._controlledReadableByteStream._state;
    return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize;
  }

  function He(e, t) {
    var r = e._pendingPullIntos.peek();

    if ("closed" === e._controlledReadableByteStream._state) {
      if (0 !== t) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
    } else {
      if (0 === t) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
      if (r.bytesFilled + t > r.byteLength) throw new RangeError("bytesWritten out of range");
    }

    r.buffer = _de(r.buffer), Le(e, t);
  }

  function Ve(e, t) {
    var r = e._pendingPullIntos.peek();

    if ("closed" === e._controlledReadableByteStream._state) {
      if (0 !== t.byteLength) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
    } else if (0 === t.byteLength) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");

    if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
    if (r.bufferByteLength !== t.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
    if (r.bytesFilled + t.byteLength > r.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
    var o = t.byteLength;
    r.buffer = _de(t.buffer), Le(e, o);
  }

  function Ue(e, t, r, o, n, a, i) {
    t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, t._byobRequest = null, t._queue = t._queueTotalSize = void 0, ge(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, t._autoAllocateChunkSize = i, t._pendingPullIntos = new g(), e._readableStreamController = t;
    f(u(r()), function () {
      return t._started = !0, Te(t), null;
    }, function (e) {
      return Ye(t, e), null;
    });
  }

  function Ge(e) {
    return new TypeError("ReadableStreamBYOBRequest.prototype.".concat(e, " can only be used on a ReadableStreamBYOBRequest"));
  }

  function Xe(e) {
    return new TypeError("ReadableByteStreamController.prototype.".concat(e, " can only be used on a ReadableByteStreamController"));
  }

  function Je(e, t) {
    if ("byob" !== (e = "".concat(e))) throw new TypeError("".concat(t, " '").concat(e, "' is not a valid enumeration value for ReadableStreamReaderMode"));
    return e;
  }

  function Ke(e) {
    return new ReadableStreamBYOBReader(e);
  }

  function Ze(e, t) {
    e._reader._readIntoRequests.push(t);
  }

  function et(e) {
    return e._reader._readIntoRequests.length;
  }

  function tt(e) {
    var t = e._reader;
    return void 0 !== t && !!rt(t);
  }

  Object.defineProperties(ReadableByteStreamController.prototype, {
    close: {
      enumerable: !0
    },
    enqueue: {
      enumerable: !0
    },
    error: {
      enumerable: !0
    },
    byobRequest: {
      enumerable: !0
    },
    desiredSize: {
      enumerable: !0
    }
  }), n(ReadableByteStreamController.prototype.close, "close"), n(ReadableByteStreamController.prototype.enqueue, "enqueue"), n(ReadableByteStreamController.prototype.error, "error"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
    value: "ReadableByteStreamController",
    configurable: !0
  });

  var ReadableStreamBYOBReader =
  /*#__PURE__*/
  function () {
    function ReadableStreamBYOBReader(e) {
      _classCallCheck(this, ReadableStreamBYOBReader);

      if (I(e, 1, "ReadableStreamBYOBReader"), x(e, "First parameter"), qr(e)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
      if (!we(e._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
      P(this, e), this._readIntoRequests = new g();
    }

    _createClass(ReadableStreamBYOBReader, [{
      key: "cancel",
      value: function cancel() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return rt(this) ? void 0 === this._ownerReadableStream ? c(W("cancel")) : q(this, e) : c(at("cancel"));
      }
    }, {
      key: "read",
      value: function read(e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!rt(this)) return c(at("read"));
        if (!ArrayBuffer.isView(e)) return c(new TypeError("view must be an array buffer view"));
        if (0 === e.byteLength) return c(new TypeError("view must have non-zero byteLength"));
        if (0 === e.buffer.byteLength) return c(new TypeError("view's buffer must have non-zero byteLength"));
        if (_fe(e.buffer)) return c(new TypeError("view's buffer has been detached"));
        var r;

        try {
          r = function (e, t) {
            var r;
            return z(e, t), {
              min: Q(null !== (r = null == e ? void 0 : e.min) && void 0 !== r ? r : 1, "".concat(t, " has member 'min' that"))
            };
          }(t, "options");
        } catch (e) {
          return c(e);
        }

        var o = r.min;
        if (0 === o) return c(new TypeError("options.min must be greater than 0"));

        if (function (e) {
          return ve(e.constructor);
        }(e)) {
          if (o > e.byteLength) return c(new RangeError("options.min must be less than or equal to view's byteLength"));
        } else if (o > e.length) return c(new RangeError("options.min must be less than or equal to view's length"));

        if (void 0 === this._ownerReadableStream) return c(W("read from"));
        var n, a;
        var i = s(function (e, t) {
          n = e, a = t;
        });
        return ot(this, e, o, {
          _chunkSteps: function _chunkSteps(e) {
            return n({
              value: e,
              done: !1
            });
          },
          _closeSteps: function _closeSteps(e) {
            return n({
              value: e,
              done: !0
            });
          },
          _errorSteps: function _errorSteps(e) {
            return a(e);
          }
        }), i;
      }
    }, {
      key: "releaseLock",
      value: function releaseLock() {
        if (!rt(this)) throw at("releaseLock");
        void 0 !== this._ownerReadableStream && function (e) {
          E(e);
          var t = new TypeError("Reader was released");
          nt(e, t);
        }(this);
      }
    }, {
      key: "closed",
      get: function get() {
        return rt(this) ? this._closedPromise : c(at("closed"));
      }
    }]);

    return ReadableStreamBYOBReader;
  }();

  function rt(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") && e instanceof ReadableStreamBYOBReader;
  }

  function ot(e, t, r, o) {
    var n = e._ownerReadableStream;
    n._disturbed = !0, "errored" === n._state ? o._errorSteps(n._storedError) : ze(n._readableStreamController, t, r, o);
  }

  function nt(e, t) {
    var r = e._readIntoRequests;
    e._readIntoRequests = new g(), r.forEach(function (e) {
      e._errorSteps(t);
    });
  }

  function at(e) {
    return new TypeError("ReadableStreamBYOBReader.prototype.".concat(e, " can only be used on a ReadableStreamBYOBReader"));
  }

  function it(e, t) {
    var r = e.highWaterMark;
    if (void 0 === r) return t;
    if (ae(r) || r < 0) throw new RangeError("Invalid highWaterMark");
    return r;
  }

  function lt(e) {
    var t = e.size;
    return t || function () {
      return 1;
    };
  }

  function st(e, t) {
    z(e, t);
    var r = null == e ? void 0 : e.highWaterMark,
        o = null == e ? void 0 : e.size;
    return {
      highWaterMark: void 0 === r ? void 0 : M(r),
      size: void 0 === o ? void 0 : ut(o, "".concat(t, " has member 'size' that"))
    };
  }

  function ut(e, t) {
    return L(e, t), function (t) {
      return M(e(t));
    };
  }

  function ct(e, t, r) {
    return L(e, r), function (r) {
      return S(e, t, [r]);
    };
  }

  function dt(e, t, r) {
    return L(e, r), function () {
      return S(e, t, []);
    };
  }

  function ft(e, t, r) {
    return L(e, r), function (r) {
      return y(e, t, [r]);
    };
  }

  function bt(e, t, r) {
    return L(e, r), function (r, o) {
      return S(e, t, [r, o]);
    };
  }

  function mt(e, t) {
    if (!yt(e)) throw new TypeError("".concat(t, " is not a WritableStream."));
  }

  Object.defineProperties(ReadableStreamBYOBReader.prototype, {
    cancel: {
      enumerable: !0
    },
    read: {
      enumerable: !0
    },
    releaseLock: {
      enumerable: !0
    },
    closed: {
      enumerable: !0
    }
  }), n(ReadableStreamBYOBReader.prototype.cancel, "cancel"), n(ReadableStreamBYOBReader.prototype.read, "read"), n(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
    value: "ReadableStreamBYOBReader",
    configurable: !0
  });
  var ht = "function" == typeof AbortController;

  var WritableStream =
  /*#__PURE__*/
  function () {
    function WritableStream() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, WritableStream);

      void 0 === e ? e = null : F(e, "First parameter");

      var r = st(t, "Second parameter"),
          o = function (e, t) {
        z(e, t);
        var r = null == e ? void 0 : e.abort,
            o = null == e ? void 0 : e.close,
            n = null == e ? void 0 : e.start,
            a = null == e ? void 0 : e.type,
            i = null == e ? void 0 : e.write;
        return {
          abort: void 0 === r ? void 0 : ct(r, e, "".concat(t, " has member 'abort' that")),
          close: void 0 === o ? void 0 : dt(o, e, "".concat(t, " has member 'close' that")),
          start: void 0 === n ? void 0 : ft(n, e, "".concat(t, " has member 'start' that")),
          write: void 0 === i ? void 0 : bt(i, e, "".concat(t, " has member 'write' that")),
          type: a
        };
      }(e, "First parameter");

      pt(this);
      if (void 0 !== o.type) throw new RangeError("Invalid type is specified");
      var n = lt(r);
      !function (e, t, r, o) {
        var n = Object.create(WritableStreamDefaultController.prototype);
        var a, i, l, s;
        a = void 0 !== t.start ? function () {
          return t.start(n);
        } : function () {};
        i = void 0 !== t.write ? function (e) {
          return t.write(e, n);
        } : function () {
          return u(void 0);
        };
        l = void 0 !== t.close ? function () {
          return t.close();
        } : function () {
          return u(void 0);
        };
        s = void 0 !== t.abort ? function (e) {
          return t.abort(e);
        } : function () {
          return u(void 0);
        };
        zt(e, n, a, i, l, s, r, o);
      }(this, o, it(r, 1), n);
    }

    _createClass(WritableStream, [{
      key: "abort",
      value: function abort() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return yt(this) ? St(this) ? c(new TypeError("Cannot abort a stream that already has a writer")) : gt(this, e) : c(Qt("abort"));
      }
    }, {
      key: "close",
      value: function close() {
        return yt(this) ? St(this) ? c(new TypeError("Cannot close a stream that already has a writer")) : Ct(this) ? c(new TypeError("Cannot close an already-closing stream")) : vt(this) : c(Qt("close"));
      }
    }, {
      key: "getWriter",
      value: function getWriter() {
        if (!yt(this)) throw Qt("getWriter");
        return _t(this);
      }
    }, {
      key: "locked",
      get: function get() {
        if (!yt(this)) throw Qt("locked");
        return St(this);
      }
    }]);

    return WritableStream;
  }();

  function _t(e) {
    return new WritableStreamDefaultWriter(e);
  }

  function pt(e) {
    e._state = "writable", e._storedError = void 0, e._writer = void 0, e._writableStreamController = void 0, e._writeRequests = new g(), e._inFlightWriteRequest = void 0, e._closeRequest = void 0, e._inFlightCloseRequest = void 0, e._pendingAbortRequest = void 0, e._backpressure = !1;
  }

  function yt(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_writableStreamController") && e instanceof WritableStream;
  }

  function St(e) {
    return void 0 !== e._writer;
  }

  function gt(e, t) {
    var r;
    if ("closed" === e._state || "errored" === e._state) return u(void 0);
    e._writableStreamController._abortReason = t, null === (r = e._writableStreamController._abortController) || void 0 === r || r.abort(t);
    var o = e._state;
    if ("closed" === o || "errored" === o) return u(void 0);
    if (void 0 !== e._pendingAbortRequest) return e._pendingAbortRequest._promise;
    var n = !1;
    "erroring" === o && (n = !0, t = void 0);
    var a = s(function (r, o) {
      e._pendingAbortRequest = {
        _promise: void 0,
        _resolve: r,
        _reject: o,
        _reason: t,
        _wasAlreadyErroring: n
      };
    });
    return e._pendingAbortRequest._promise = a, n || Rt(e, t), a;
  }

  function vt(e) {
    var t = e._state;
    if ("closed" === t || "errored" === t) return c(new TypeError("The stream (in ".concat(t, " state) is not in the writable state and cannot be closed")));
    var r = s(function (t, r) {
      var o = {
        _resolve: t,
        _reject: r
      };
      e._closeRequest = o;
    }),
        o = e._writer;
    var n;
    return void 0 !== o && e._backpressure && "writable" === t && tr(o), Se(n = e._writableStreamController, At, 0), It(n), r;
  }

  function wt(e, t) {
    "writable" !== e._state ? Tt(e) : Rt(e, t);
  }

  function Rt(e, t) {
    var r = e._writableStreamController;
    e._state = "erroring", e._storedError = t;
    var o = e._writer;
    void 0 !== o && Ot(o, t), !function (e) {
      if (void 0 === e._inFlightWriteRequest && void 0 === e._inFlightCloseRequest) return !1;
      return !0;
    }(e) && r._started && Tt(e);
  }

  function Tt(e) {
    e._state = "errored", e._writableStreamController[w]();
    var t = e._storedError;
    if (e._writeRequests.forEach(function (e) {
      e._reject(t);
    }), e._writeRequests = new g(), void 0 === e._pendingAbortRequest) return void Pt(e);
    var r = e._pendingAbortRequest;
    if (e._pendingAbortRequest = void 0, r._wasAlreadyErroring) return r._reject(t), void Pt(e);
    f(e._writableStreamController[v](r._reason), function () {
      return r._resolve(), Pt(e), null;
    }, function (t) {
      return r._reject(t), Pt(e), null;
    });
  }

  function Ct(e) {
    return void 0 !== e._closeRequest || void 0 !== e._inFlightCloseRequest;
  }

  function Pt(e) {
    void 0 !== e._closeRequest && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0);
    var t = e._writer;
    void 0 !== t && Gt(t, e._storedError);
  }

  function qt(e, t) {
    var r = e._writer;
    void 0 !== r && t !== e._backpressure && (t ? function (e) {
      Jt(e);
    }(r) : tr(r)), e._backpressure = t;
  }

  Object.defineProperties(WritableStream.prototype, {
    abort: {
      enumerable: !0
    },
    close: {
      enumerable: !0
    },
    getWriter: {
      enumerable: !0
    },
    locked: {
      enumerable: !0
    }
  }), n(WritableStream.prototype.abort, "abort"), n(WritableStream.prototype.close, "close"), n(WritableStream.prototype.getWriter, "getWriter"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
    value: "WritableStream",
    configurable: !0
  });

  var WritableStreamDefaultWriter =
  /*#__PURE__*/
  function () {
    function WritableStreamDefaultWriter(e) {
      _classCallCheck(this, WritableStreamDefaultWriter);

      if (I(e, 1, "WritableStreamDefaultWriter"), mt(e, "First parameter"), St(e)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
      this._ownerWritableStream = e, e._writer = this;
      var t = e._state;
      if ("writable" === t) !Ct(e) && e._backpressure ? Jt(this) : Zt(this), Vt(this);else if ("erroring" === t) Kt(this, e._storedError), Vt(this);else if ("closed" === t) Zt(this), Vt(r = this), Xt(r);else {
        var _t12 = e._storedError;
        Kt(this, _t12), Ut(this, _t12);
      }
      var r;
    }

    _createClass(WritableStreamDefaultWriter, [{
      key: "abort",
      value: function abort() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return Et(this) ? void 0 === this._ownerWritableStream ? c(Ht("abort")) : function (e, t) {
          return gt(e._ownerWritableStream, t);
        }(this, e) : c(Nt("abort"));
      }
    }, {
      key: "close",
      value: function close() {
        if (!Et(this)) return c(Nt("close"));
        var e = this._ownerWritableStream;
        return void 0 === e ? c(Ht("close")) : Ct(e) ? c(new TypeError("Cannot close an already-closing stream")) : Wt(this);
      }
    }, {
      key: "releaseLock",
      value: function releaseLock() {
        if (!Et(this)) throw Nt("releaseLock");
        void 0 !== this._ownerWritableStream && jt(this);
      }
    }, {
      key: "write",
      value: function write() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return Et(this) ? void 0 === this._ownerWritableStream ? c(Ht("write to")) : kt(this, e) : c(Nt("write"));
      }
    }, {
      key: "closed",
      get: function get() {
        return Et(this) ? this._closedPromise : c(Nt("closed"));
      }
    }, {
      key: "desiredSize",
      get: function get() {
        if (!Et(this)) throw Nt("desiredSize");
        if (void 0 === this._ownerWritableStream) throw Ht("desiredSize");
        return function (e) {
          var t = e._ownerWritableStream,
              r = t._state;
          if ("errored" === r || "erroring" === r) return null;
          if ("closed" === r) return 0;
          return Ft(t._writableStreamController);
        }(this);
      }
    }, {
      key: "ready",
      get: function get() {
        return Et(this) ? this._readyPromise : c(Nt("ready"));
      }
    }]);

    return WritableStreamDefaultWriter;
  }();

  function Et(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_ownerWritableStream") && e instanceof WritableStreamDefaultWriter;
  }

  function Wt(e) {
    return vt(e._ownerWritableStream);
  }

  function Bt(e, t) {
    "pending" === e._closedPromiseState ? Gt(e, t) : function (e, t) {
      Ut(e, t);
    }(e, t);
  }

  function Ot(e, t) {
    "pending" === e._readyPromiseState ? er(e, t) : function (e, t) {
      Kt(e, t);
    }(e, t);
  }

  function jt(e) {
    var t = e._ownerWritableStream,
        r = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
    Ot(e, r), Bt(e, r), t._writer = void 0, e._ownerWritableStream = void 0;
  }

  function kt(e, t) {
    var r = e._ownerWritableStream,
        o = r._writableStreamController,
        n = function (e, t) {
      try {
        return e._strategySizeAlgorithm(t);
      } catch (t) {
        return $t(e, t), 1;
      }
    }(o, t);

    if (r !== e._ownerWritableStream) return c(Ht("write to"));
    var a = r._state;
    if ("errored" === a) return c(r._storedError);
    if (Ct(r) || "closed" === a) return c(new TypeError("The stream is closing or closed and cannot be written to"));
    if ("erroring" === a) return c(r._storedError);

    var i = function (e) {
      return s(function (t, r) {
        var o = {
          _resolve: t,
          _reject: r
        };

        e._writeRequests.push(o);
      });
    }(r);

    return function (e, t, r) {
      try {
        Se(e, t, r);
      } catch (t) {
        return void $t(e, t);
      }

      var o = e._controlledWritableStream;

      if (!Ct(o) && "writable" === o._state) {
        qt(o, Mt(e));
      }

      It(e);
    }(o, t, n), i;
  }

  Object.defineProperties(WritableStreamDefaultWriter.prototype, {
    abort: {
      enumerable: !0
    },
    close: {
      enumerable: !0
    },
    releaseLock: {
      enumerable: !0
    },
    write: {
      enumerable: !0
    },
    closed: {
      enumerable: !0
    },
    desiredSize: {
      enumerable: !0
    },
    ready: {
      enumerable: !0
    }
  }), n(WritableStreamDefaultWriter.prototype.abort, "abort"), n(WritableStreamDefaultWriter.prototype.close, "close"), n(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock"), n(WritableStreamDefaultWriter.prototype.write, "write"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
    value: "WritableStreamDefaultWriter",
    configurable: !0
  });
  var At = {};

  var WritableStreamDefaultController =
  /*#__PURE__*/
  function () {
    function WritableStreamDefaultController() {
      _classCallCheck(this, WritableStreamDefaultController);

      throw new TypeError("Illegal constructor");
    }

    _createClass(WritableStreamDefaultController, [{
      key: "error",
      value: function error() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!Dt(this)) throw xt("error");
        "writable" === this._controlledWritableStream._state && Yt(this, e);
      }
    }, {
      key: v,
      value: function value(e) {
        var t = this._abortAlgorithm(e);

        return Lt(this), t;
      }
    }, {
      key: w,
      value: function value() {
        ge(this);
      }
    }, {
      key: "abortReason",
      get: function get() {
        if (!Dt(this)) throw xt("abortReason");
        return this._abortReason;
      }
    }, {
      key: "signal",
      get: function get() {
        if (!Dt(this)) throw xt("signal");
        if (void 0 === this._abortController) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        return this._abortController.signal;
      }
    }]);

    return WritableStreamDefaultController;
  }();

  function Dt(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledWritableStream") && e instanceof WritableStreamDefaultController;
  }

  function zt(e, t, r, o, n, a, i, l) {
    t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, ge(t), t._abortReason = void 0, t._abortController = function () {
      if (ht) return new AbortController();
    }(), t._started = !1, t._strategySizeAlgorithm = l, t._strategyHWM = i, t._writeAlgorithm = o, t._closeAlgorithm = n, t._abortAlgorithm = a;
    var s = Mt(t);
    qt(e, s);
    f(u(r()), function () {
      return t._started = !0, It(t), null;
    }, function (r) {
      return t._started = !0, wt(e, r), null;
    });
  }

  function Lt(e) {
    e._writeAlgorithm = void 0, e._closeAlgorithm = void 0, e._abortAlgorithm = void 0, e._strategySizeAlgorithm = void 0;
  }

  function Ft(e) {
    return e._strategyHWM - e._queueTotalSize;
  }

  function It(e) {
    var t = e._controlledWritableStream;
    if (!e._started) return;
    if (void 0 !== t._inFlightWriteRequest) return;
    if ("erroring" === t._state) return void Tt(t);
    if (0 === e._queue.length) return;

    var r = e._queue.peek().value;

    r === At ? function (e) {
      var t = e._controlledWritableStream;
      (function (e) {
        e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0;
      })(t), ye(e);

      var r = e._closeAlgorithm();

      Lt(e), f(r, function () {
        return function (e) {
          e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, "erroring" === e._state && (e._storedError = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = "closed";
          var t = e._writer;
          void 0 !== t && Xt(t);
        }(t), null;
      }, function (e) {
        return function (e, t) {
          e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), wt(e, t);
        }(t, e), null;
      });
    }(e) : function (e, t) {
      var r = e._controlledWritableStream;
      !function (e) {
        e._inFlightWriteRequest = e._writeRequests.shift();
      }(r);

      var o = e._writeAlgorithm(t);

      f(o, function () {
        !function (e) {
          e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0;
        }(r);
        var t = r._state;

        if (ye(e), !Ct(r) && "writable" === t) {
          var _t13 = Mt(e);

          qt(r, _t13);
        }

        return It(e), null;
      }, function (t) {
        return "writable" === r._state && Lt(e), function (e, t) {
          e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, wt(e, t);
        }(r, t), null;
      });
    }(e, r);
  }

  function $t(e, t) {
    "writable" === e._controlledWritableStream._state && Yt(e, t);
  }

  function Mt(e) {
    return Ft(e) <= 0;
  }

  function Yt(e, t) {
    var r = e._controlledWritableStream;
    Lt(e), Rt(r, t);
  }

  function Qt(e) {
    return new TypeError("WritableStream.prototype.".concat(e, " can only be used on a WritableStream"));
  }

  function xt(e) {
    return new TypeError("WritableStreamDefaultController.prototype.".concat(e, " can only be used on a WritableStreamDefaultController"));
  }

  function Nt(e) {
    return new TypeError("WritableStreamDefaultWriter.prototype.".concat(e, " can only be used on a WritableStreamDefaultWriter"));
  }

  function Ht(e) {
    return new TypeError("Cannot " + e + " a stream using a released writer");
  }

  function Vt(e) {
    e._closedPromise = s(function (t, r) {
      e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = "pending";
    });
  }

  function Ut(e, t) {
    Vt(e), Gt(e, t);
  }

  function Gt(e, t) {
    void 0 !== e._closedPromise_reject && (_(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "rejected");
  }

  function Xt(e) {
    void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "resolved");
  }

  function Jt(e) {
    e._readyPromise = s(function (t, r) {
      e._readyPromise_resolve = t, e._readyPromise_reject = r;
    }), e._readyPromiseState = "pending";
  }

  function Kt(e, t) {
    Jt(e), er(e, t);
  }

  function Zt(e) {
    Jt(e), tr(e);
  }

  function er(e, t) {
    void 0 !== e._readyPromise_reject && (_(e._readyPromise), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "rejected");
  }

  function tr(e) {
    void 0 !== e._readyPromise_resolve && (e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "fulfilled");
  }

  Object.defineProperties(WritableStreamDefaultController.prototype, {
    abortReason: {
      enumerable: !0
    },
    signal: {
      enumerable: !0
    },
    error: {
      enumerable: !0
    }
  }), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
    value: "WritableStreamDefaultController",
    configurable: !0
  });
  var rr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof global ? global : void 0;

  var or = function () {
    var e = null == rr ? void 0 : rr.DOMException;
    return function (e) {
      if ("function" != typeof e && "object" != _typeof(e)) return !1;
      if ("DOMException" !== e.name) return !1;

      try {
        return new e(), !0;
      } catch (e) {
        return !1;
      }
    }(e) ? e : void 0;
  }() || function () {
    var e = function e(_e5, t) {
      this.message = _e5 || "", this.name = t || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
    };

    return n(e, "DOMException"), e.prototype = Object.create(Error.prototype), Object.defineProperty(e.prototype, "constructor", {
      value: e,
      writable: !0,
      configurable: !0
    }), e;
  }();

  function nr(e, r, o, n, a, i) {
    var l = N(e),
        h = _t(r);

    e._disturbed = !0;
    var p = !1,
        y = u(void 0);
    return s(function (S, g) {
      var v;

      if (void 0 !== i) {
        if (v = function v() {
          var t = void 0 !== i.reason ? i.reason : new or("Aborted", "AbortError"),
              o = [];
          n || o.push(function () {
            return "writable" === r._state ? gt(r, t) : u(void 0);
          }), a || o.push(function () {
            return "readable" === e._state ? Er(e, t) : u(void 0);
          }), q(function () {
            return Promise.all(o.map(function (e) {
              return e();
            }));
          }, !0, t);
        }, i.aborted) return void v();
        i.addEventListener("abort", v);
      }

      var w, R, T;

      if (P(e, l._closedPromise, function (e) {
        return n ? W(!0, e) : q(function () {
          return gt(r, e);
        }, !0, e), null;
      }), P(r, h._closedPromise, function (t) {
        return a ? W(!0, t) : q(function () {
          return Er(e, t);
        }, !0, t), null;
      }), w = e, R = l._closedPromise, T = function T() {
        return o ? W() : q(function () {
          return function (e) {
            var t = e._ownerWritableStream,
                r = t._state;
            return Ct(t) || "closed" === r ? u(void 0) : "errored" === r ? c(t._storedError) : Wt(e);
          }(h);
        }), null;
      }, "closed" === w._state ? T() : b(R, T), Ct(r) || "closed" === r._state) {
        var _t14 = new TypeError("the destination writable stream closed before all data could be piped to it");

        a ? W(!0, _t14) : q(function () {
          return Er(e, _t14);
        }, !0, _t14);
      }

      function C() {
        var e = y;
        return d(y, function () {
          return e !== y ? C() : void 0;
        });
      }

      function P(e, t, r) {
        "errored" === e._state ? r(e._storedError) : m(t, r);
      }

      function q(e, t, o) {
        function n() {
          return f(e(), function () {
            return B(t, o);
          }, function (e) {
            return B(!0, e);
          }), null;
        }

        p || (p = !0, "writable" !== r._state || Ct(r) ? n() : b(C(), n));
      }

      function W(e, t) {
        p || (p = !0, "writable" !== r._state || Ct(r) ? B(e, t) : b(C(), function () {
          return B(e, t);
        }));
      }

      function B(e, t) {
        return jt(h), E(l), void 0 !== i && i.removeEventListener("abort", v), e ? g(t) : S(void 0), null;
      }

      _(s(function (e, r) {
        !function o(n) {
          n ? e() : d(p ? u(!0) : d(h._readyPromise, function () {
            return s(function (e, r) {
              J(l, {
                _chunkSteps: function _chunkSteps(r) {
                  y = d(kt(h, r), void 0, t), e(!1);
                },
                _closeSteps: function _closeSteps() {
                  return e(!0);
                },
                _errorSteps: r
              });
            });
          }), o, r);
        }(!1);
      }));
    });
  }

  var ReadableStreamDefaultController =
  /*#__PURE__*/
  function () {
    function ReadableStreamDefaultController() {
      _classCallCheck(this, ReadableStreamDefaultController);

      throw new TypeError("Illegal constructor");
    }

    _createClass(ReadableStreamDefaultController, [{
      key: "close",
      value: function close() {
        if (!ar(this)) throw hr("close");
        if (!br(this)) throw new TypeError("The stream is not in a state that permits close");
        ur(this);
      }
    }, {
      key: "enqueue",
      value: function enqueue() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!ar(this)) throw hr("enqueue");
        if (!br(this)) throw new TypeError("The stream is not in a state that permits enqueue");
        return cr(this, e);
      }
    }, {
      key: "error",
      value: function error() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!ar(this)) throw hr("error");
        dr(this, e);
      }
    }, {
      key: R,
      value: function value(e) {
        ge(this);

        var t = this._cancelAlgorithm(e);

        return sr(this), t;
      }
    }, {
      key: T,
      value: function value(e) {
        var t = this._controlledReadableStream;

        if (this._queue.length > 0) {
          var _r5 = ye(this);

          this._closeRequested && 0 === this._queue.length ? (sr(this), Wr(t)) : ir(this), e._chunkSteps(_r5);
        } else H(t, e), ir(this);
      }
    }, {
      key: C,
      value: function value() {}
    }, {
      key: "desiredSize",
      get: function get() {
        if (!ar(this)) throw hr("desiredSize");
        return fr(this);
      }
    }]);

    return ReadableStreamDefaultController;
  }();

  function ar(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableStream") && e instanceof ReadableStreamDefaultController;
  }

  function ir(e) {
    if (!lr(e)) return;
    if (e._pulling) return void (e._pullAgain = !0);
    e._pulling = !0;
    f(e._pullAlgorithm(), function () {
      return e._pulling = !1, e._pullAgain && (e._pullAgain = !1, ir(e)), null;
    }, function (t) {
      return dr(e, t), null;
    });
  }

  function lr(e) {
    var t = e._controlledReadableStream;
    if (!br(e)) return !1;
    if (!e._started) return !1;
    if (qr(t) && U(t) > 0) return !0;
    return fr(e) > 0;
  }

  function sr(e) {
    e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0, e._strategySizeAlgorithm = void 0;
  }

  function ur(e) {
    if (!br(e)) return;
    var t = e._controlledReadableStream;
    e._closeRequested = !0, 0 === e._queue.length && (sr(e), Wr(t));
  }

  function cr(e, t) {
    if (!br(e)) return;
    var r = e._controlledReadableStream;
    if (qr(r) && U(r) > 0) V(r, t, !1);else {
      var _r6;

      try {
        _r6 = e._strategySizeAlgorithm(t);
      } catch (t) {
        throw dr(e, t), t;
      }

      try {
        Se(e, t, _r6);
      } catch (t) {
        throw dr(e, t), t;
      }
    }
    ir(e);
  }

  function dr(e, t) {
    var r = e._controlledReadableStream;
    "readable" === r._state && (ge(e), sr(e), Br(r, t));
  }

  function fr(e) {
    var t = e._controlledReadableStream._state;
    return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize;
  }

  function br(e) {
    var t = e._controlledReadableStream._state;
    return !e._closeRequested && "readable" === t;
  }

  function mr(e, t, r, o, n, a, i) {
    t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, ge(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = i, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, e._readableStreamController = t;
    f(u(r()), function () {
      return t._started = !0, ir(t), null;
    }, function (e) {
      return dr(t, e), null;
    });
  }

  function hr(e) {
    return new TypeError("ReadableStreamDefaultController.prototype.".concat(e, " can only be used on a ReadableStreamDefaultController"));
  }

  function _r(e, t) {
    return we(e._readableStreamController) ? function (e) {
      var t,
          r,
          o,
          n,
          a,
          i = N(e),
          l = !1,
          c = !1,
          d = !1,
          f = !1,
          b = !1;
      var h = s(function (e) {
        a = e;
      });

      function _(e) {
        m(e._closedPromise, function (t) {
          return e !== i || (Ye(o._readableStreamController, t), Ye(n._readableStreamController, t), f && b || a(void 0)), null;
        });
      }

      function y() {
        rt(i) && (E(i), i = N(e), _(i));
        J(i, {
          _chunkSteps: function _chunkSteps(t) {
            _p(function () {
              c = !1, d = !1;
              var r = t;
              var i = t;
              if (!f && !b) try {
                i = pe(t);
              } catch (t) {
                return Ye(o._readableStreamController, t), Ye(n._readableStreamController, t), void a(Er(e, t));
              }
              f || Me(o._readableStreamController, r), b || Me(n._readableStreamController, i), l = !1, c ? g() : d && v();
            });
          },
          _closeSteps: function _closeSteps() {
            l = !1, f || $e(o._readableStreamController), b || $e(n._readableStreamController), o._readableStreamController._pendingPullIntos.length > 0 && He(o._readableStreamController, 0), n._readableStreamController._pendingPullIntos.length > 0 && He(n._readableStreamController, 0), f && b || a(void 0);
          },
          _errorSteps: function _errorSteps() {
            l = !1;
          }
        });
      }

      function S(t, r) {
        X(i) && (E(i), i = Ke(e), _(i));
        var s = r ? n : o,
            u = r ? o : n;
        ot(i, t, 1, {
          _chunkSteps: function _chunkSteps(t) {
            _p(function () {
              c = !1, d = !1;
              var o = r ? b : f;
              if (r ? f : b) o || Ve(s._readableStreamController, t);else {
                var _r7;

                try {
                  _r7 = pe(t);
                } catch (t) {
                  return Ye(s._readableStreamController, t), Ye(u._readableStreamController, t), void a(Er(e, t));
                }

                o || Ve(s._readableStreamController, t), Me(u._readableStreamController, _r7);
              }
              l = !1, c ? g() : d && v();
            });
          },
          _closeSteps: function _closeSteps(e) {
            l = !1;
            var t = r ? b : f,
                o = r ? f : b;
            t || $e(s._readableStreamController), o || $e(u._readableStreamController), void 0 !== e && (t || Ve(s._readableStreamController, e), !o && u._readableStreamController._pendingPullIntos.length > 0 && He(u._readableStreamController, 0)), t && o || a(void 0);
          },
          _errorSteps: function _errorSteps() {
            l = !1;
          }
        });
      }

      function g() {
        if (l) return c = !0, u(void 0);
        l = !0;
        var e = xe(o._readableStreamController);
        return null === e ? y() : S(e._view, !1), u(void 0);
      }

      function v() {
        if (l) return d = !0, u(void 0);
        l = !0;
        var e = xe(n._readableStreamController);
        return null === e ? y() : S(e._view, !0), u(void 0);
      }

      function w(o) {
        if (f = !0, t = o, b) {
          var _o4 = ue([t, r]),
              _n = Er(e, _o4);

          a(_n);
        }

        return h;
      }

      function R(o) {
        if (b = !0, r = o, f) {
          var _o5 = ue([t, r]),
              _n2 = Er(e, _o5);

          a(_n2);
        }

        return h;
      }

      function T() {}

      return o = Tr(T, g, w), n = Tr(T, v, R), _(i), [o, n];
    }(e) : function (e, t) {
      var r = N(e);
      var o,
          n,
          a,
          i,
          l,
          c = !1,
          d = !1,
          f = !1,
          b = !1;
      var h = s(function (e) {
        l = e;
      });

      function _() {
        if (c) return d = !0, u(void 0);
        c = !0;
        return J(r, {
          _chunkSteps: function _chunkSteps(e) {
            _p(function () {
              d = !1;
              var t = e,
                  r = e;
              f || cr(a._readableStreamController, t), b || cr(i._readableStreamController, r), c = !1, d && _();
            });
          },
          _closeSteps: function _closeSteps() {
            c = !1, f || ur(a._readableStreamController), b || ur(i._readableStreamController), f && b || l(void 0);
          },
          _errorSteps: function _errorSteps() {
            c = !1;
          }
        }), u(void 0);
      }

      function y(t) {
        if (f = !0, o = t, b) {
          var _t15 = ue([o, n]),
              _r8 = Er(e, _t15);

          l(_r8);
        }

        return h;
      }

      function S(t) {
        if (b = !0, n = t, f) {
          var _t16 = ue([o, n]),
              _r9 = Er(e, _t16);

          l(_r9);
        }

        return h;
      }

      function g() {}

      return a = Rr(g, _, y), i = Rr(g, _, S), m(r._closedPromise, function (e) {
        return dr(a._readableStreamController, e), dr(i._readableStreamController, e), f && b || l(void 0), null;
      }), [a, i];
    }(e);
  }

  function pr(e) {
    return r(o = e) && void 0 !== o.getReader ? function (e) {
      var o;

      function n() {
        var t;

        try {
          t = e.read();
        } catch (e) {
          return c(e);
        }

        return h(t, function (e) {
          if (!r(e)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
          if (e.done) ur(o._readableStreamController);else {
            var _t17 = e.value;
            cr(o._readableStreamController, _t17);
          }
        });
      }

      function a(t) {
        try {
          return u(e.cancel(t));
        } catch (e) {
          return c(e);
        }
      }

      return o = Rr(t, n, a, 0), o;
    }(e.getReader()) : function (e) {
      var o;

      var n = _e(e, "async");

      function a() {
        var e;

        try {
          e = function (e) {
            var t = y(e.nextMethod, e.iterator, []);
            if (!r(t)) throw new TypeError("The iterator.next() method must return an object");
            return t;
          }(n);
        } catch (e) {
          return c(e);
        }

        return h(u(e), function (e) {
          if (!r(e)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");

          var t = function (e) {
            return Boolean(e.done);
          }(e);

          if (t) ur(o._readableStreamController);else {
            var _t18 = function (e) {
              return e.value;
            }(e);

            cr(o._readableStreamController, _t18);
          }
        });
      }

      function i(e) {
        var t = n.iterator;
        var o, a;

        try {
          o = me(t, "return");
        } catch (e) {
          return c(e);
        }

        if (void 0 === o) return u(void 0);

        try {
          a = y(o, t, [e]);
        } catch (e) {
          return c(e);
        }

        return h(u(a), function (e) {
          if (!r(e)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
        });
      }

      return o = Rr(t, a, i, 0), o;
    }(e);
    var o;
  }

  function yr(e, t, r) {
    return L(e, r), function (r) {
      return S(e, t, [r]);
    };
  }

  function Sr(e, t, r) {
    return L(e, r), function (r) {
      return S(e, t, [r]);
    };
  }

  function gr(e, t, r) {
    return L(e, r), function (r) {
      return y(e, t, [r]);
    };
  }

  function vr(e, t) {
    if ("bytes" !== (e = "".concat(e))) throw new TypeError("".concat(t, " '").concat(e, "' is not a valid enumeration value for ReadableStreamType"));
    return e;
  }

  function wr(e, t) {
    z(e, t);
    var r = null == e ? void 0 : e.preventAbort,
        o = null == e ? void 0 : e.preventCancel,
        n = null == e ? void 0 : e.preventClose,
        a = null == e ? void 0 : e.signal;
    return void 0 !== a && function (e, t) {
      if (!function (e) {
        if ("object" != _typeof(e) || null === e) return !1;

        try {
          return "boolean" == typeof e.aborted;
        } catch (e) {
          return !1;
        }
      }(e)) throw new TypeError("".concat(t, " is not an AbortSignal."));
    }(a, "".concat(t, " has member 'signal' that")), {
      preventAbort: Boolean(r),
      preventCancel: Boolean(o),
      preventClose: Boolean(n),
      signal: a
    };
  }

  Object.defineProperties(ReadableStreamDefaultController.prototype, {
    close: {
      enumerable: !0
    },
    enqueue: {
      enumerable: !0
    },
    error: {
      enumerable: !0
    },
    desiredSize: {
      enumerable: !0
    }
  }), n(ReadableStreamDefaultController.prototype.close, "close"), n(ReadableStreamDefaultController.prototype.enqueue, "enqueue"), n(ReadableStreamDefaultController.prototype.error, "error"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
    value: "ReadableStreamDefaultController",
    configurable: !0
  });

  var ReadableStream =
  /*#__PURE__*/
  function () {
    function ReadableStream() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, ReadableStream);

      void 0 === e ? e = null : F(e, "First parameter");

      var r = st(t, "Second parameter"),
          o = function (e, t) {
        z(e, t);
        var r = e,
            o = null == r ? void 0 : r.autoAllocateChunkSize,
            n = null == r ? void 0 : r.cancel,
            a = null == r ? void 0 : r.pull,
            i = null == r ? void 0 : r.start,
            l = null == r ? void 0 : r.type;
        return {
          autoAllocateChunkSize: void 0 === o ? void 0 : Q(o, "".concat(t, " has member 'autoAllocateChunkSize' that")),
          cancel: void 0 === n ? void 0 : yr(n, r, "".concat(t, " has member 'cancel' that")),
          pull: void 0 === a ? void 0 : Sr(a, r, "".concat(t, " has member 'pull' that")),
          start: void 0 === i ? void 0 : gr(i, r, "".concat(t, " has member 'start' that")),
          type: void 0 === l ? void 0 : vr(l, "".concat(t, " has member 'type' that"))
        };
      }(e, "First parameter");

      if (Cr(this), "bytes" === o.type) {
        if (void 0 !== r.size) throw new RangeError("The strategy for a byte stream cannot have a size function");
        !function (e, t, r) {
          var o = Object.create(ReadableByteStreamController.prototype);
          var n, a, i;
          n = void 0 !== t.start ? function () {
            return t.start(o);
          } : function () {}, a = void 0 !== t.pull ? function () {
            return t.pull(o);
          } : function () {
            return u(void 0);
          }, i = void 0 !== t.cancel ? function (e) {
            return t.cancel(e);
          } : function () {
            return u(void 0);
          };
          var l = t.autoAllocateChunkSize;
          if (0 === l) throw new TypeError("autoAllocateChunkSize must be greater than 0");
          Ue(e, o, n, a, i, r, l);
        }(this, o, it(r, 0));
      } else {
        var _e6 = lt(r);

        !function (e, t, r, o) {
          var n = Object.create(ReadableStreamDefaultController.prototype);
          var a, i, l;
          a = void 0 !== t.start ? function () {
            return t.start(n);
          } : function () {}, i = void 0 !== t.pull ? function () {
            return t.pull(n);
          } : function () {
            return u(void 0);
          }, l = void 0 !== t.cancel ? function (e) {
            return t.cancel(e);
          } : function () {
            return u(void 0);
          }, mr(e, n, a, i, l, r, o);
        }(this, o, it(r, 1), _e6);
      }
    }

    _createClass(ReadableStream, [{
      key: "cancel",
      value: function cancel() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        return Pr(this) ? qr(this) ? c(new TypeError("Cannot cancel a stream that already has a reader")) : Er(this, e) : c(Or("cancel"));
      }
    }, {
      key: "getReader",
      value: function getReader() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!Pr(this)) throw Or("getReader");
        return void 0 === function (e, t) {
          z(e, t);
          var r = null == e ? void 0 : e.mode;
          return {
            mode: void 0 === r ? void 0 : Je(r, "".concat(t, " has member 'mode' that"))
          };
        }(e, "First parameter").mode ? N(this) : Ke(this);
      }
    }, {
      key: "pipeThrough",
      value: function pipeThrough(e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!Pr(this)) throw Or("pipeThrough");
        I(e, 1, "pipeThrough");

        var r = function (e, t) {
          z(e, t);
          var r = null == e ? void 0 : e.readable;
          $(r, "readable", "ReadableWritablePair"), x(r, "".concat(t, " has member 'readable' that"));
          var o = null == e ? void 0 : e.writable;
          return $(o, "writable", "ReadableWritablePair"), mt(o, "".concat(t, " has member 'writable' that")), {
            readable: r,
            writable: o
          };
        }(e, "First parameter"),
            o = wr(t, "Second parameter");

        if (qr(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (St(r.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        return _(nr(this, r.writable, o.preventClose, o.preventAbort, o.preventCancel, o.signal)), r.readable;
      }
    }, {
      key: "pipeTo",
      value: function pipeTo(e) {
        var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!Pr(this)) return c(Or("pipeTo"));
        if (void 0 === e) return c("Parameter 1 is required in 'pipeTo'.");
        if (!yt(e)) return c(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        var r;

        try {
          r = wr(t, "Second parameter");
        } catch (e) {
          return c(e);
        }

        return qr(this) ? c(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : St(e) ? c(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : nr(this, e, r.preventClose, r.preventAbort, r.preventCancel, r.signal);
      }
    }, {
      key: "tee",
      value: function tee() {
        if (!Pr(this)) throw Or("tee");
        return ue(_r(this));
      }
    }, {
      key: "values",
      value: function values() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!Pr(this)) throw Or("values");
        return function (e, t) {
          var r = N(e),
              o = new te(r, t),
              n = Object.create(re);
          return n._asyncIteratorImpl = o, n;
        }(this, function (e, t) {
          z(e, t);
          var r = null == e ? void 0 : e.preventCancel;
          return {
            preventCancel: Boolean(r)
          };
        }(e, "First parameter").preventCancel);
      }
    }, {
      key: he,
      value: function value(e) {
        return this.values(e);
      }
    }, {
      key: "locked",
      get: function get() {
        if (!Pr(this)) throw Or("locked");
        return qr(this);
      }
    }], [{
      key: "from",
      value: function from(e) {
        return pr(e);
      }
    }]);

    return ReadableStream;
  }();

  function Rr(e, t, r) {
    var o = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
      return 1;
    };
    var a = Object.create(ReadableStream.prototype);
    Cr(a);
    return mr(a, Object.create(ReadableStreamDefaultController.prototype), e, t, r, o, n), a;
  }

  function Tr(e, t, r) {
    var o = Object.create(ReadableStream.prototype);
    Cr(o);
    return Ue(o, Object.create(ReadableByteStreamController.prototype), e, t, r, 0, void 0), o;
  }

  function Cr(e) {
    e._state = "readable", e._reader = void 0, e._storedError = void 0, e._disturbed = !1;
  }

  function Pr(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_readableStreamController") && e instanceof ReadableStream;
  }

  function qr(e) {
    return void 0 !== e._reader;
  }

  function Er(e, r) {
    if (e._disturbed = !0, "closed" === e._state) return u(void 0);
    if ("errored" === e._state) return c(e._storedError);
    Wr(e);
    var o = e._reader;

    if (void 0 !== o && rt(o)) {
      var _e7 = o._readIntoRequests;
      o._readIntoRequests = new g(), _e7.forEach(function (e) {
        e._closeSteps(void 0);
      });
    }

    return h(e._readableStreamController[R](r), t);
  }

  function Wr(e) {
    e._state = "closed";
    var t = e._reader;

    if (void 0 !== t && (k(t), X(t))) {
      var _e8 = t._readRequests;
      t._readRequests = new g(), _e8.forEach(function (e) {
        e._closeSteps();
      });
    }
  }

  function Br(e, t) {
    e._state = "errored", e._storedError = t;
    var r = e._reader;
    void 0 !== r && (j(r, t), X(r) ? K(r, t) : nt(r, t));
  }

  function Or(e) {
    return new TypeError("ReadableStream.prototype.".concat(e, " can only be used on a ReadableStream"));
  }

  function jr(e, t) {
    z(e, t);
    var r = null == e ? void 0 : e.highWaterMark;
    return $(r, "highWaterMark", "QueuingStrategyInit"), {
      highWaterMark: M(r)
    };
  }

  Object.defineProperties(ReadableStream, {
    from: {
      enumerable: !0
    }
  }), Object.defineProperties(ReadableStream.prototype, {
    cancel: {
      enumerable: !0
    },
    getReader: {
      enumerable: !0
    },
    pipeThrough: {
      enumerable: !0
    },
    pipeTo: {
      enumerable: !0
    },
    tee: {
      enumerable: !0
    },
    values: {
      enumerable: !0
    },
    locked: {
      enumerable: !0
    }
  }), n(ReadableStream.from, "from"), n(ReadableStream.prototype.cancel, "cancel"), n(ReadableStream.prototype.getReader, "getReader"), n(ReadableStream.prototype.pipeThrough, "pipeThrough"), n(ReadableStream.prototype.pipeTo, "pipeTo"), n(ReadableStream.prototype.tee, "tee"), n(ReadableStream.prototype.values, "values"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {
    value: "ReadableStream",
    configurable: !0
  }), Object.defineProperty(ReadableStream.prototype, he, {
    value: ReadableStream.prototype.values,
    writable: !0,
    configurable: !0
  });

  var kr = function kr(e) {
    return e.byteLength;
  };

  n(kr, "size");

  var ByteLengthQueuingStrategy =
  /*#__PURE__*/
  function () {
    function ByteLengthQueuingStrategy(e) {
      _classCallCheck(this, ByteLengthQueuingStrategy);

      I(e, 1, "ByteLengthQueuingStrategy"), e = jr(e, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e.highWaterMark;
    }

    _createClass(ByteLengthQueuingStrategy, [{
      key: "highWaterMark",
      get: function get() {
        if (!Dr(this)) throw Ar("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
    }, {
      key: "size",
      get: function get() {
        if (!Dr(this)) throw Ar("size");
        return kr;
      }
    }]);

    return ByteLengthQueuingStrategy;
  }();

  function Ar(e) {
    return new TypeError("ByteLengthQueuingStrategy.prototype.".concat(e, " can only be used on a ByteLengthQueuingStrategy"));
  }

  function Dr(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_byteLengthQueuingStrategyHighWaterMark") && e instanceof ByteLengthQueuingStrategy;
  }

  Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: !0
    },
    size: {
      enumerable: !0
    }
  }), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
    value: "ByteLengthQueuingStrategy",
    configurable: !0
  });

  var zr = function zr() {
    return 1;
  };

  n(zr, "size");

  var CountQueuingStrategy =
  /*#__PURE__*/
  function () {
    function CountQueuingStrategy(e) {
      _classCallCheck(this, CountQueuingStrategy);

      I(e, 1, "CountQueuingStrategy"), e = jr(e, "First parameter"), this._countQueuingStrategyHighWaterMark = e.highWaterMark;
    }

    _createClass(CountQueuingStrategy, [{
      key: "highWaterMark",
      get: function get() {
        if (!Fr(this)) throw Lr("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
    }, {
      key: "size",
      get: function get() {
        if (!Fr(this)) throw Lr("size");
        return zr;
      }
    }]);

    return CountQueuingStrategy;
  }();

  function Lr(e) {
    return new TypeError("CountQueuingStrategy.prototype.".concat(e, " can only be used on a CountQueuingStrategy"));
  }

  function Fr(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_countQueuingStrategyHighWaterMark") && e instanceof CountQueuingStrategy;
  }

  function Ir(e, t, r) {
    return L(e, r), function (r) {
      return S(e, t, [r]);
    };
  }

  function $r(e, t, r) {
    return L(e, r), function (r) {
      return y(e, t, [r]);
    };
  }

  function Mr(e, t, r) {
    return L(e, r), function (r, o) {
      return S(e, t, [r, o]);
    };
  }

  function Yr(e, t, r) {
    return L(e, r), function (r) {
      return S(e, t, [r]);
    };
  }

  Object.defineProperties(CountQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: !0
    },
    size: {
      enumerable: !0
    }
  }), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
    value: "CountQueuingStrategy",
    configurable: !0
  });

  var TransformStream =
  /*#__PURE__*/
  function () {
    function TransformStream() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      _classCallCheck(this, TransformStream);

      void 0 === e && (e = null);

      var o = st(t, "Second parameter"),
          n = st(r, "Third parameter"),
          a = function (e, t) {
        z(e, t);
        var r = null == e ? void 0 : e.cancel,
            o = null == e ? void 0 : e.flush,
            n = null == e ? void 0 : e.readableType,
            a = null == e ? void 0 : e.start,
            i = null == e ? void 0 : e.transform,
            l = null == e ? void 0 : e.writableType;
        return {
          cancel: void 0 === r ? void 0 : Yr(r, e, "".concat(t, " has member 'cancel' that")),
          flush: void 0 === o ? void 0 : Ir(o, e, "".concat(t, " has member 'flush' that")),
          readableType: n,
          start: void 0 === a ? void 0 : $r(a, e, "".concat(t, " has member 'start' that")),
          transform: void 0 === i ? void 0 : Mr(i, e, "".concat(t, " has member 'transform' that")),
          writableType: l
        };
      }(e, "First parameter");

      if (void 0 !== a.readableType) throw new RangeError("Invalid readableType specified");
      if (void 0 !== a.writableType) throw new RangeError("Invalid writableType specified");
      var i = it(n, 0),
          l = lt(n),
          d = it(o, 1),
          b = lt(o);
      var m;
      !function (e, t, r, o, n, a) {
        function i() {
          return t;
        }

        function l(t) {
          return function (e, t) {
            var r = e._transformStreamController;

            if (e._backpressure) {
              return h(e._backpressureChangePromise, function () {
                var o = e._writable;
                if ("erroring" === o._state) throw o._storedError;
                return Jr(r, t);
              });
            }

            return Jr(r, t);
          }(e, t);
        }

        function u(t) {
          return function (e, t) {
            var r = e._transformStreamController;
            if (void 0 !== r._finishPromise) return r._finishPromise;
            var o = e._readable;
            r._finishPromise = s(function (e, t) {
              r._finishPromise_resolve = e, r._finishPromise_reject = t;
            });

            var n = r._cancelAlgorithm(t);

            return Gr(r), f(n, function () {
              return "errored" === o._state ? eo(r, o._storedError) : (dr(o._readableStreamController, t), Zr(r)), null;
            }, function (e) {
              return dr(o._readableStreamController, e), eo(r, e), null;
            }), r._finishPromise;
          }(e, t);
        }

        function c() {
          return function (e) {
            var t = e._transformStreamController;
            if (void 0 !== t._finishPromise) return t._finishPromise;
            var r = e._readable;
            t._finishPromise = s(function (e, r) {
              t._finishPromise_resolve = e, t._finishPromise_reject = r;
            });

            var o = t._flushAlgorithm();

            return Gr(t), f(o, function () {
              return "errored" === r._state ? eo(t, r._storedError) : (ur(r._readableStreamController), Zr(t)), null;
            }, function (e) {
              return dr(r._readableStreamController, e), eo(t, e), null;
            }), t._finishPromise;
          }(e);
        }

        function d() {
          return function (e) {
            return Vr(e, !1), e._backpressureChangePromise;
          }(e);
        }

        function b(t) {
          return function (e, t) {
            var r = e._transformStreamController;
            if (void 0 !== r._finishPromise) return r._finishPromise;
            var o = e._writable;
            r._finishPromise = s(function (e, t) {
              r._finishPromise_resolve = e, r._finishPromise_reject = t;
            });

            var n = r._cancelAlgorithm(t);

            return Gr(r), f(n, function () {
              return "errored" === o._state ? eo(r, o._storedError) : ($t(o._writableStreamController, t), Hr(e), Zr(r)), null;
            }, function (t) {
              return $t(o._writableStreamController, t), Hr(e), eo(r, t), null;
            }), r._finishPromise;
          }(e, t);
        }

        e._writable = function (e, t, r, o) {
          var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
          var a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {
            return 1;
          };
          var i = Object.create(WritableStream.prototype);
          return pt(i), zt(i, Object.create(WritableStreamDefaultController.prototype), e, t, r, o, n, a), i;
        }(i, l, c, u, r, o), e._readable = Rr(i, d, b, n, a), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, Vr(e, !0), e._transformStreamController = void 0;
      }(this, s(function (e) {
        m = e;
      }), d, b, i, l), function (e, t) {
        var r = Object.create(TransformStreamDefaultController.prototype);
        var o, n, a;
        o = void 0 !== t.transform ? function (e) {
          return t.transform(e, r);
        } : function (e) {
          try {
            return Xr(r, e), u(void 0);
          } catch (e) {
            return c(e);
          }
        };
        n = void 0 !== t.flush ? function () {
          return t.flush(r);
        } : function () {
          return u(void 0);
        };
        a = void 0 !== t.cancel ? function (e) {
          return t.cancel(e);
        } : function () {
          return u(void 0);
        };
        !function (e, t, r, o, n) {
          t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = o, t._cancelAlgorithm = n, t._finishPromise = void 0, t._finishPromise_resolve = void 0, t._finishPromise_reject = void 0;
        }(e, r, o, n, a);
      }(this, a), void 0 !== a.start ? m(a.start(this._transformStreamController)) : m(void 0);
    }

    _createClass(TransformStream, [{
      key: "readable",
      get: function get() {
        if (!Qr(this)) throw to("readable");
        return this._readable;
      }
    }, {
      key: "writable",
      get: function get() {
        if (!Qr(this)) throw to("writable");
        return this._writable;
      }
    }]);

    return TransformStream;
  }();

  function Qr(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_transformStreamController") && e instanceof TransformStream;
  }

  function xr(e, t) {
    dr(e._readable._readableStreamController, t), Nr(e, t);
  }

  function Nr(e, t) {
    Gr(e._transformStreamController), $t(e._writable._writableStreamController, t), Hr(e);
  }

  function Hr(e) {
    e._backpressure && Vr(e, !1);
  }

  function Vr(e, t) {
    void 0 !== e._backpressureChangePromise && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = s(function (t) {
      e._backpressureChangePromise_resolve = t;
    }), e._backpressure = t;
  }

  Object.defineProperties(TransformStream.prototype, {
    readable: {
      enumerable: !0
    },
    writable: {
      enumerable: !0
    }
  }), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
    value: "TransformStream",
    configurable: !0
  });

  var TransformStreamDefaultController =
  /*#__PURE__*/
  function () {
    function TransformStreamDefaultController() {
      _classCallCheck(this, TransformStreamDefaultController);

      throw new TypeError("Illegal constructor");
    }

    _createClass(TransformStreamDefaultController, [{
      key: "enqueue",
      value: function enqueue() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!Ur(this)) throw Kr("enqueue");
        Xr(this, e);
      }
    }, {
      key: "error",
      value: function error() {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : void 0;
        if (!Ur(this)) throw Kr("error");
        var t;
        t = e, xr(this._controlledTransformStream, t);
      }
    }, {
      key: "terminate",
      value: function terminate() {
        if (!Ur(this)) throw Kr("terminate");
        !function (e) {
          var t = e._controlledTransformStream;
          ur(t._readable._readableStreamController);
          var r = new TypeError("TransformStream terminated");
          Nr(t, r);
        }(this);
      }
    }, {
      key: "desiredSize",
      get: function get() {
        if (!Ur(this)) throw Kr("desiredSize");
        return fr(this._controlledTransformStream._readable._readableStreamController);
      }
    }]);

    return TransformStreamDefaultController;
  }();

  function Ur(e) {
    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledTransformStream") && e instanceof TransformStreamDefaultController;
  }

  function Gr(e) {
    e._transformAlgorithm = void 0, e._flushAlgorithm = void 0, e._cancelAlgorithm = void 0;
  }

  function Xr(e, t) {
    var r = e._controlledTransformStream,
        o = r._readable._readableStreamController;
    if (!br(o)) throw new TypeError("Readable side is not in a state that permits enqueue");

    try {
      cr(o, t);
    } catch (e) {
      throw Nr(r, e), r._readable._storedError;
    }

    var n = function (e) {
      return !lr(e);
    }(o);

    n !== r._backpressure && Vr(r, !0);
  }

  function Jr(e, t) {
    return h(e._transformAlgorithm(t), void 0, function (t) {
      throw xr(e._controlledTransformStream, t), t;
    });
  }

  function Kr(e) {
    return new TypeError("TransformStreamDefaultController.prototype.".concat(e, " can only be used on a TransformStreamDefaultController"));
  }

  function Zr(e) {
    void 0 !== e._finishPromise_resolve && (e._finishPromise_resolve(), e._finishPromise_resolve = void 0, e._finishPromise_reject = void 0);
  }

  function eo(e, t) {
    void 0 !== e._finishPromise_reject && (_(e._finishPromise), e._finishPromise_reject(t), e._finishPromise_resolve = void 0, e._finishPromise_reject = void 0);
  }

  function to(e) {
    return new TypeError("TransformStream.prototype.".concat(e, " can only be used on a TransformStream"));
  }

  Object.defineProperties(TransformStreamDefaultController.prototype, {
    enqueue: {
      enumerable: !0
    },
    error: {
      enumerable: !0
    },
    terminate: {
      enumerable: !0
    },
    desiredSize: {
      enumerable: !0
    }
  }), n(TransformStreamDefaultController.prototype.enqueue, "enqueue"), n(TransformStreamDefaultController.prototype.error, "error"), n(TransformStreamDefaultController.prototype.terminate, "terminate"), "symbol" == _typeof(Symbol.toStringTag) && Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
    value: "TransformStreamDefaultController",
    configurable: !0
  });
  var ro = {
    ReadableStream: ReadableStream,
    ReadableStreamDefaultController: ReadableStreamDefaultController,
    ReadableByteStreamController: ReadableByteStreamController,
    ReadableStreamBYOBRequest: ReadableStreamBYOBRequest,
    ReadableStreamDefaultReader: ReadableStreamDefaultReader,
    ReadableStreamBYOBReader: ReadableStreamBYOBReader,
    WritableStream: WritableStream,
    WritableStreamDefaultController: WritableStreamDefaultController,
    WritableStreamDefaultWriter: WritableStreamDefaultWriter,
    ByteLengthQueuingStrategy: ByteLengthQueuingStrategy,
    CountQueuingStrategy: CountQueuingStrategy,
    TransformStream: TransformStream,
    TransformStreamDefaultController: TransformStreamDefaultController
  };
  if (void 0 !== rr) for (var _e9 in ro) {
    Object.prototype.hasOwnProperty.call(ro, _e9) && Object.defineProperty(rr, _e9, {
      value: ro[_e9],
      writable: !0,
      configurable: !0
    });
  }
  e.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, e.CountQueuingStrategy = CountQueuingStrategy, e.ReadableByteStreamController = ReadableByteStreamController, e.ReadableStream = ReadableStream, e.ReadableStreamBYOBReader = ReadableStreamBYOBReader, e.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest, e.ReadableStreamDefaultController = ReadableStreamDefaultController, e.ReadableStreamDefaultReader = ReadableStreamDefaultReader, e.TransformStream = TransformStream, e.TransformStreamDefaultController = TransformStreamDefaultController, e.WritableStream = WritableStream, e.WritableStreamDefaultController = WritableStreamDefaultController, e.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
});