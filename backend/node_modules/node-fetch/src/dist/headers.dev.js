"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromRawHeaders = fromRawHeaders;
exports["default"] = void 0;

var _nodeUtil = require("node:util");

var _nodeHttp = _interopRequireDefault(require("node:http"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* c8 ignore next 9 */
var validateHeaderName = typeof _nodeHttp["default"].validateHeaderName === 'function' ? _nodeHttp["default"].validateHeaderName : function (name) {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    var error = new TypeError("Header name must be a valid HTTP token [".concat(name, "]"));
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_HTTP_TOKEN'
    });
    throw error;
  }
};
/* c8 ignore next 9 */

var validateHeaderValue = typeof _nodeHttp["default"].validateHeaderValue === 'function' ? _nodeHttp["default"].validateHeaderValue : function (name, value) {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
    var error = new TypeError("Invalid character in header content [\"".concat(name, "\"]"));
    Object.defineProperty(error, 'code', {
      value: 'ERR_INVALID_CHAR'
    });
    throw error;
  }
};
/**
 * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
 */

/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
 * These actions include retrieving, setting, adding to, and removing.
 * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
 * You can add to this using methods like append() (see Examples.)
 * In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 */

var Headers =
/*#__PURE__*/
function (_URLSearchParams) {
  _inherits(Headers, _URLSearchParams);

  /**
   * Headers class
   *
   * @constructor
   * @param {HeadersInit} [init] - Response headers
   */
  function Headers(init) {
    var _this;

    _classCallCheck(this, Headers);

    // Validate and normalize init object in [name, value(s)][]

    /** @type {string[][]} */
    var result = [];

    if (init instanceof Headers) {
      var raw = init.raw();

      var _loop = function _loop() {
        var _result;

        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            name = _Object$entries$_i[0],
            values = _Object$entries$_i[1];

        (_result = result).push.apply(_result, _toConsumableArray(values.map(function (value) {
          return [name, value];
        })));
      };

      for (var _i = 0, _Object$entries = Object.entries(raw); _i < _Object$entries.length; _i++) {
        _loop();
      }
    } else if (init == null) {// eslint-disable-line no-eq-null, eqeqeq
      // No op
    } else if (_typeof(init) === 'object' && !_nodeUtil.types.isBoxedPrimitive(init)) {
      var method = init[Symbol.iterator]; // eslint-disable-next-line no-eq-null, eqeqeq

      if (method == null) {
        var _result2;

        // Record<ByteString, ByteString>
        (_result2 = result).push.apply(_result2, _toConsumableArray(Object.entries(init)));
      } else {
        if (typeof method !== 'function') {
          throw new TypeError('Header pairs must be iterable');
        } // Sequence<sequence<ByteString>>
        // Note: per spec we have to first exhaust the lists then process them


        result = _toConsumableArray(init).map(function (pair) {
          if (_typeof(pair) !== 'object' || _nodeUtil.types.isBoxedPrimitive(pair)) {
            throw new TypeError('Each header pair must be an iterable object');
          }

          return _toConsumableArray(pair);
        }).map(function (pair) {
          if (pair.length !== 2) {
            throw new TypeError('Each header pair must be a name/value tuple');
          }

          return _toConsumableArray(pair);
        });
      }
    } else {
      throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
    } // Validate and lowercase


    result = result.length > 0 ? result.map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          name = _ref2[0],
          value = _ref2[1];

      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return [String(name).toLowerCase(), String(value)];
    }) : undefined;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Headers).call(this, result)); // Returning a Proxy that will lowercase key names, validate parameters and sort keys
    // eslint-disable-next-line no-constructor-return

    return _possibleConstructorReturn(_this, new Proxy(_assertThisInitialized(_this), {
      get: function get(target, p, receiver) {
        switch (p) {
          case 'append':
          case 'set':
            return function (name, value) {
              validateHeaderName(name);
              validateHeaderValue(name, String(value));
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value));
            };

          case 'delete':
          case 'has':
          case 'getAll':
            return function (name) {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
            };

          case 'keys':
            return function () {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };

          default:
            return Reflect.get(target, p, receiver);
        }
      }
    }));
    /* c8 ignore next */
  }

  _createClass(Headers, [{
    key: "toString",
    value: function toString() {
      return Object.prototype.toString.call(this);
    }
  }, {
    key: "get",
    value: function get(name) {
      var values = this.getAll(name);

      if (values.length === 0) {
        return null;
      }

      var value = values.join(', ');

      if (/^content-encoding$/i.test(name)) {
        value = value.toLowerCase();
      }

      return value;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "values",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function values() {
      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, name;

      return regeneratorRuntime.wrap(function values$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 3;
              _iterator2 = this.keys()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 12;
                break;
              }

              name = _step2.value;
              _context.next = 9;
              return this.get(name);

            case 9:
              _iteratorNormalCompletion2 = true;
              _context.next = 5;
              break;

            case 12:
              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](3);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t0;

            case 18:
              _context.prev = 18;
              _context.prev = 19;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 21:
              _context.prev = 21;

              if (!_didIteratorError2) {
                _context.next = 24;
                break;
              }

              throw _iteratorError2;

            case 24:
              return _context.finish(21);

            case 25:
              return _context.finish(18);

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, values, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
    /**
     * @type {() => IterableIterator<[string, string]>}
     */

  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function entries() {
      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, name;

      return regeneratorRuntime.wrap(function entries$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context2.prev = 3;
              _iterator3 = this.keys()[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context2.next = 12;
                break;
              }

              name = _step3.value;
              _context2.next = 9;
              return [name, this.get(name)];

            case 9:
              _iteratorNormalCompletion3 = true;
              _context2.next = 5;
              break;

            case 12:
              _context2.next = 18;
              break;

            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](3);
              _didIteratorError3 = true;
              _iteratorError3 = _context2.t0;

            case 18:
              _context2.prev = 18;
              _context2.prev = 19;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 21:
              _context2.prev = 21;

              if (!_didIteratorError3) {
                _context2.next = 24;
                break;
              }

              throw _iteratorError3;

            case 24:
              return _context2.finish(21);

            case 25:
              return _context2.finish(18);

            case 26:
            case "end":
              return _context2.stop();
          }
        }
      }, entries, this, [[3, 14, 18, 26], [19,, 21, 25]]);
    })
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this.entries();
    }
    /**
     * Node-fetch non-spec method
     * returning all headers and their values as array
     * @returns {Record<string, string[]>}
     */

  }, {
    key: "raw",
    value: function raw() {
      var _this2 = this;

      return _toConsumableArray(this.keys()).reduce(function (result, key) {
        result[key] = _this2.getAll(key);
        return result;
      }, {});
    }
    /**
     * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
     */

  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value() {
      var _this3 = this;

      return _toConsumableArray(this.keys()).reduce(function (result, key) {
        var values = _this3.getAll(key); // Http.request() only supports string as Host header.
        // This hack makes specifying custom Host header possible.


        if (key === 'host') {
          result[key] = values[0];
        } else {
          result[key] = values.length > 1 ? values : values[0];
        }

        return result;
      }, {});
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Headers;
}(_wrapNativeSuper(URLSearchParams));
/**
 * Re-shaping object for Web IDL tests
 * Only need to do it for overridden methods
 */


exports["default"] = Headers;
Object.defineProperties(Headers.prototype, ['get', 'entries', 'forEach', 'values'].reduce(function (result, property) {
  result[property] = {
    enumerable: true
  };
  return result;
}, {}));
/**
 * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
 * not conform to HTTP grammar productions.
 * @param {import('http').IncomingMessage['rawHeaders']} headers
 */

function fromRawHeaders() {
  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return new Headers(headers // Split into pairs
  .reduce(function (result, value, index, array) {
    if (index % 2 === 0) {
      result.push(array.slice(index, index + 2));
    }

    return result;
  }, []).filter(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        value = _ref4[1];

    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value));
      return true;
    } catch (_unused) {
      return false;
    }
  }));
}