"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFormData = toFormData;

var _from = require("fetch-blob/from.js");

var _esmMin = require("formdata-polyfill/esm.min.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

var s = 0;
var S = {
  START_BOUNDARY: s++,
  HEADER_FIELD_START: s++,
  HEADER_FIELD: s++,
  HEADER_VALUE_START: s++,
  HEADER_VALUE: s++,
  HEADER_VALUE_ALMOST_DONE: s++,
  HEADERS_ALMOST_DONE: s++,
  PART_DATA_START: s++,
  PART_DATA: s++,
  END: s++
};
var f = 1;
var F = {
  PART_BOUNDARY: f,
  LAST_BOUNDARY: f *= 2
};
var LF = 10;
var CR = 13;
var SPACE = 32;
var HYPHEN = 45;
var COLON = 58;
var A = 97;
var Z = 122;

var lower = function lower(c) {
  return c | 0x20;
};

var noop = function noop() {};

var MultipartParser =
/*#__PURE__*/
function () {
  /**
   * @param {string} boundary
   */
  function MultipartParser(boundary) {
    _classCallCheck(this, MultipartParser);

    this.index = 0;
    this.flags = 0;
    this.onHeaderEnd = noop;
    this.onHeaderField = noop;
    this.onHeadersEnd = noop;
    this.onHeaderValue = noop;
    this.onPartBegin = noop;
    this.onPartData = noop;
    this.onPartEnd = noop;
    this.boundaryChars = {};
    boundary = '\r\n--' + boundary;
    var ui8a = new Uint8Array(boundary.length);

    for (var i = 0; i < boundary.length; i++) {
      ui8a[i] = boundary.charCodeAt(i);
      this.boundaryChars[ui8a[i]] = true;
    }

    this.boundary = ui8a;
    this.lookbehind = new Uint8Array(this.boundary.length + 8);
    this.state = S.START_BOUNDARY;
  }
  /**
   * @param {Uint8Array} data
   */


  _createClass(MultipartParser, [{
    key: "write",
    value: function write(data) {
      var _this = this;

      var i = 0;
      var length_ = data.length;
      var previousIndex = this.index;
      var lookbehind = this.lookbehind,
          boundary = this.boundary,
          boundaryChars = this.boundaryChars,
          index = this.index,
          state = this.state,
          flags = this.flags;
      var boundaryLength = this.boundary.length;
      var boundaryEnd = boundaryLength - 1;
      var bufferLength = data.length;
      var c;
      var cl;

      var mark = function mark(name) {
        _this[name + 'Mark'] = i;
      };

      var clear = function clear(name) {
        delete _this[name + 'Mark'];
      };

      var callback = function callback(callbackSymbol, start, end, ui8a) {
        if (start === undefined || start !== end) {
          _this[callbackSymbol](ui8a && ui8a.subarray(start, end));
        }
      };

      var dataCallback = function dataCallback(name, clear) {
        var markSymbol = name + 'Mark';

        if (!(markSymbol in _this)) {
          return;
        }

        if (clear) {
          callback(name, _this[markSymbol], i, data);
          delete _this[markSymbol];
        } else {
          callback(name, _this[markSymbol], data.length, data);
          _this[markSymbol] = 0;
        }
      };

      for (i = 0; i < length_; i++) {
        c = data[i];

        switch (state) {
          case S.START_BOUNDARY:
            if (index === boundary.length - 2) {
              if (c === HYPHEN) {
                flags |= F.LAST_BOUNDARY;
              } else if (c !== CR) {
                return;
              }

              index++;
              break;
            } else if (index - 1 === boundary.length - 2) {
              if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                state = S.END;
                flags = 0;
              } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                index = 0;
                callback('onPartBegin');
                state = S.HEADER_FIELD_START;
              } else {
                return;
              }

              break;
            }

            if (c !== boundary[index + 2]) {
              index = -2;
            }

            if (c === boundary[index + 2]) {
              index++;
            }

            break;

          case S.HEADER_FIELD_START:
            state = S.HEADER_FIELD;
            mark('onHeaderField');
            index = 0;
          // falls through

          case S.HEADER_FIELD:
            if (c === CR) {
              clear('onHeaderField');
              state = S.HEADERS_ALMOST_DONE;
              break;
            }

            index++;

            if (c === HYPHEN) {
              break;
            }

            if (c === COLON) {
              if (index === 1) {
                // empty header field
                return;
              }

              dataCallback('onHeaderField', true);
              state = S.HEADER_VALUE_START;
              break;
            }

            cl = lower(c);

            if (cl < A || cl > Z) {
              return;
            }

            break;

          case S.HEADER_VALUE_START:
            if (c === SPACE) {
              break;
            }

            mark('onHeaderValue');
            state = S.HEADER_VALUE;
          // falls through

          case S.HEADER_VALUE:
            if (c === CR) {
              dataCallback('onHeaderValue', true);
              callback('onHeaderEnd');
              state = S.HEADER_VALUE_ALMOST_DONE;
            }

            break;

          case S.HEADER_VALUE_ALMOST_DONE:
            if (c !== LF) {
              return;
            }

            state = S.HEADER_FIELD_START;
            break;

          case S.HEADERS_ALMOST_DONE:
            if (c !== LF) {
              return;
            }

            callback('onHeadersEnd');
            state = S.PART_DATA_START;
            break;

          case S.PART_DATA_START:
            state = S.PART_DATA;
            mark('onPartData');
          // falls through

          case S.PART_DATA:
            previousIndex = index;

            if (index === 0) {
              // boyer-moore derrived algorithm to safely skip non-boundary data
              i += boundaryEnd;

              while (i < bufferLength && !(data[i] in boundaryChars)) {
                i += boundaryLength;
              }

              i -= boundaryEnd;
              c = data[i];
            }

            if (index < boundary.length) {
              if (boundary[index] === c) {
                if (index === 0) {
                  dataCallback('onPartData', true);
                }

                index++;
              } else {
                index = 0;
              }
            } else if (index === boundary.length) {
              index++;

              if (c === CR) {
                // CR = part boundary
                flags |= F.PART_BOUNDARY;
              } else if (c === HYPHEN) {
                // HYPHEN = end boundary
                flags |= F.LAST_BOUNDARY;
              } else {
                index = 0;
              }
            } else if (index - 1 === boundary.length) {
              if (flags & F.PART_BOUNDARY) {
                index = 0;

                if (c === LF) {
                  // unset the PART_BOUNDARY flag
                  flags &= ~F.PART_BOUNDARY;
                  callback('onPartEnd');
                  callback('onPartBegin');
                  state = S.HEADER_FIELD_START;
                  break;
                }
              } else if (flags & F.LAST_BOUNDARY) {
                if (c === HYPHEN) {
                  callback('onPartEnd');
                  state = S.END;
                  flags = 0;
                } else {
                  index = 0;
                }
              } else {
                index = 0;
              }
            }

            if (index > 0) {
              // when matching a possible boundary, keep a lookbehind reference
              // in case it turns out to be a false lead
              lookbehind[index - 1] = c;
            } else if (previousIndex > 0) {
              // if our boundary turned out to be rubbish, the captured lookbehind
              // belongs to partData
              var _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);

              callback('onPartData', 0, previousIndex, _lookbehind);
              previousIndex = 0;
              mark('onPartData'); // reconsider the current character even so it interrupted the sequence
              // it could be the beginning of a new sequence

              i--;
            }

            break;

          case S.END:
            break;

          default:
            throw new Error("Unexpected state entered: ".concat(state));
        }
      }

      dataCallback('onHeaderField');
      dataCallback('onHeaderValue');
      dataCallback('onPartData'); // Update properties for the next call

      this.index = index;
      this.state = state;
      this.flags = flags;
    }
  }, {
    key: "end",
    value: function end() {
      if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
        this.onPartEnd();
      } else if (this.state !== S.END) {
        throw new Error('MultipartParser.end(): stream ended unexpectedly');
      }
    }
  }]);

  return MultipartParser;
}();

function _fileName(headerValue) {
  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
  var m = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);

  if (!m) {
    return;
  }

  var match = m[2] || m[3] || '';
  var filename = match.slice(match.lastIndexOf('\\') + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, function (m, code) {
    return String.fromCharCode(code);
  });
  return filename;
}

function toFormData(Body, ct) {
  var m, parser, headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks, formData, onPartData, appendToFile, appendFileToFormData, appendEntryToFormData, decoder, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

  return regeneratorRuntime.async(function toFormData$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (/multipart/i.test(ct)) {
            _context.next = 2;
            break;
          }

          throw new TypeError('Failed to fetch');

        case 2:
          m = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);

          if (m) {
            _context.next = 5;
            break;
          }

          throw new TypeError('no or bad content-type header, no multipart boundary');

        case 5:
          parser = new MultipartParser(m[1] || m[2]);
          entryChunks = [];
          formData = new _esmMin.FormData();

          onPartData = function onPartData(ui8a) {
            entryValue += decoder.decode(ui8a, {
              stream: true
            });
          };

          appendToFile = function appendToFile(ui8a) {
            entryChunks.push(ui8a);
          };

          appendFileToFormData = function appendFileToFormData() {
            var file = new _from.File(entryChunks, filename, {
              type: contentType
            });
            formData.append(entryName, file);
          };

          appendEntryToFormData = function appendEntryToFormData() {
            formData.append(entryName, entryValue);
          };

          decoder = new TextDecoder('utf-8');
          decoder.decode();

          parser.onPartBegin = function () {
            parser.onPartData = onPartData;
            parser.onPartEnd = appendEntryToFormData;
            headerField = '';
            headerValue = '';
            entryValue = '';
            entryName = '';
            contentType = '';
            filename = null;
            entryChunks.length = 0;
          };

          parser.onHeaderField = function (ui8a) {
            headerField += decoder.decode(ui8a, {
              stream: true
            });
          };

          parser.onHeaderValue = function (ui8a) {
            headerValue += decoder.decode(ui8a, {
              stream: true
            });
          };

          parser.onHeaderEnd = function () {
            headerValue += decoder.decode();
            headerField = headerField.toLowerCase();

            if (headerField === 'content-disposition') {
              // matches either a quoted-string or a token (RFC 2616 section 19.5.1)
              var _m = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);

              if (_m) {
                entryName = _m[2] || _m[3] || '';
              }

              filename = _fileName(headerValue);

              if (filename) {
                parser.onPartData = appendToFile;
                parser.onPartEnd = appendFileToFormData;
              }
            } else if (headerField === 'content-type') {
              contentType = headerValue;
            }

            headerValue = '';
            headerField = '';
          };

          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _context.prev = 20;
          _iterator = _asyncIterator(Body);

        case 22:
          _context.next = 24;
          return regeneratorRuntime.awrap(_iterator.next());

        case 24:
          _step = _context.sent;
          _iteratorNormalCompletion = _step.done;
          _context.next = 28;
          return regeneratorRuntime.awrap(_step.value);

        case 28:
          _value = _context.sent;

          if (_iteratorNormalCompletion) {
            _context.next = 35;
            break;
          }

          chunk = _value;
          parser.write(chunk);

        case 32:
          _iteratorNormalCompletion = true;
          _context.next = 22;
          break;

        case 35:
          _context.next = 41;
          break;

        case 37:
          _context.prev = 37;
          _context.t0 = _context["catch"](20);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 41:
          _context.prev = 41;
          _context.prev = 42;

          if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
            _context.next = 46;
            break;
          }

          _context.next = 46;
          return regeneratorRuntime.awrap(_iterator["return"]());

        case 46:
          _context.prev = 46;

          if (!_didIteratorError) {
            _context.next = 49;
            break;
          }

          throw _iteratorError;

        case 49:
          return _context.finish(46);

        case 50:
          return _context.finish(41);

        case 51:
          parser.end();
          return _context.abrupt("return", formData);

        case 53:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[20, 37, 41, 51], [42,, 46, 50]]);
}